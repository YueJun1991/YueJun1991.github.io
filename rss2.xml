<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Simplicity is the ultimate sophistication.]]></title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[iOS developer. Like coding and reading.]]></description>
    <pubDate>Sat, 05 Mar 2016 13:10:10 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[《活出生命的意義》閱讀筆記]]></title>
      <link>http://yoursite.com/2016/03/03/The%20read%20note%20about%20Man's%20Search%20For%20meaning/</link>
      <guid>http://yoursite.com/2016/03/03/The%20read%20note%20about%20Man's%20Search%20For%20meaning/</guid>
      <pubDate>Wed, 02 Mar 2016 16:00:00 GMT</pubDate>
      <description>
      <![CDATA[<p><img src="http://i915.photobucket.com/albums/ac360/aahkan/a0765cd3.jpg" alt="意義"></p>
<h2 id="Snippet_1"><a href="#Snippet_1" class="headerlink" title="Snippet 1"></a>Snippet 1</h2><h3 id="u524D_u8A00_P-3_-_4"><a href="#u524D_u8A00_P-3_-_4" class="headerlink" title="前言 P.3 - 4"></a>前言 P.3 - 4</h3><p>生活並非弗洛伊德所宣揚的那樣，只是簡單地祈求快樂，也並非阿德勒所教導的那樣，只是為了爭權奪利。人們或者是為了尋找生命的意義，這也是人們一生中被賦予的最艱巨的使命。弗蘭克爾發現可能找尋到生命意義的三個途徑：工作（做有意義的事）、愛（關愛他人）以及擁有克服困難的勇氣。苦難本身毫無意義，但我們可以通過自身對苦難的反應賦予其意義。</p>
<p>一些不可控的力量可能會拿走你很多東西，但它唯一無法剝奪的是你自主選擇如何應對不同處境的自由。你無法控制生命中會發生什麼，但你可以控制面對這些事情時自己的情緒與行動。</p>
<h2 id="Snippet_2"><a href="#Snippet_2" class="headerlink" title="Snippet 2"></a>Snippet 2</h2><h3 id="u81EA_u5E8F_P-9"><a href="#u81EA_u5E8F_P-9" class="headerlink" title="自序 P.9"></a>自序 P.9</h3><p>不要只想著成功──你越想成功，就越容易失敗。成功就像幸福一樣，可遇而不可求。它是一種自然而然的產物，是一個人無意識地投身于某一偉大的事業時產生的衍生品，或者是為他人奉獻時的副產品。幸福總會降臨的，成功也同樣：常常是無心插柳柳成蔭。我希望你們的一切行為服從良心，并用知識去實現它。總有一天你會發現，當然是想當長的時間之後──注意，我說的是很長一段時間后！──正是由於這種不關注，成功將會降臨于你。</p>
<h2 id="Snippet_3"><a href="#Snippet_3" class="headerlink" title="Snippet 3"></a>Snippet 3</h2><h3 id="u5728_u96C6_u4E2D_u71DF_u7684_u7D93_u6B77_P-7"><a href="#u5728_u96C6_u4E2D_u71DF_u7684_u7D93_u6B77_P-7" class="headerlink" title="在集中營的經歷 P.7"></a>在集中營的經歷 P.7</h3><p>我們不喜歡談論我們的過去。對於經歷過這場噩夢的人來說，所有的解釋都是多餘的，而對於沒有這種經歷的人來說，他們不會理解我們過去的感受，也不會理解我們現在的感覺。</p>
<h2 id="Snippet_4"><a href="#Snippet_4" class="headerlink" title="Snippet 4"></a>Snippet 4</h2><h3 id="u5728_u96C6_u4E2D_u71DF_u7684_u7D93_u6B77_P-86_-_89_-_91_-_92_-_93_-_95_-_97"><a href="#u5728_u96C6_u4E2D_u71DF_u7684_u7D93_u6B77_P-86_-_89_-_91_-_92_-_93_-_95_-_97" class="headerlink" title="在集中營的經歷 P.86 - 89 - 91 - 92 - 93 - 95 - 97"></a>在集中營的經歷 P.86 - 89 - 91 - 92 - 93 - 95 - 97</h3><p>看不到未來的人之所以自甘沉淪，是因為他發現自己老在回憶。</p>
<p>對自己的未來喪失信心的犯人，註定要走向毀滅。由於他對未來失去了信念，他也就喪失了對精神的把我。他自甘墮落，成為行尸走肉。</p>
<p>一般來說，精神崩潰的犯人一開始是早上拒絕穿衣洗漱，或拒絕出操。任何勸說、任何威脅對他都不起作用。他就那麼賴在那裡，一動不動。如果這種情況是疾病引起的，他會拒絕去病號區，也拒絕做任何有助於自己恢復的事。他就那樣放棄了。他縮在自己的軀殼里，不再關心任何事情。</p>
<p>尼采說過：“知道為什麼而活的人，便能生存。”這可以作為所有心理治療師的座右銘。</p>
<p>我們真正需要的，是在生活態度上來個根本的轉變。我們需要了解自身，而且需要說服那些絕望的人：我們期望生活給予什麼并不重要，重要的是生活對我們有什麼期望。我們不應該再問生活的意義是什麼，而應該像每時每刻都被生活質問的人那樣去思考自身，我們的回答不是說與想，而是採取正確的行動。生命最終意味著承擔與接收所有的挑戰，完成自己應該完成的任務這一巨大責任。</p>
<p>這些任務（也就是生命的意義）在每個人身上，在每個時刻都是不同的，因此不可能對生命的意義作一般的定義。對生命意義的質疑，沒有唯一的答案。“生命”的意義不是某種含糊的東西，而是非常實在和具體的。它構成人的命運，而每個人的命運都是獨特的。你和你的命運無法跟任何其他人及其命運進行比較。生活永不重複，不同問題需要不同的應對。有時你發現所處的情況需要你採取行動來確定自己的命運，有時你會覺得深思熟慮更為可取，有時你會發現順其自然是正道。每種情況都有其特殊性，正確的應對也只能有一個。</p>
<p>如果你發現經受磨難是命中註定的，那你就應當把經受磨難作為自己獨特的任務。你必須承認，即使在經受磨難時，你也是獨特的、孤獨的一個人。沒有人能夠解除你的磨難，替代你的痛苦。你獨特的機會就依存于自己承受重負的方式之中。</p>
<p>這種獨特性使每個人的情況千差萬別，因此讓每個人意識到生命的意義，也就使他有可能完成其創造性的作品，享受到人類之愛。一旦他意識到自己是不可替代的，那他就會充分意識到自己的責任，也就永遠不會拋棄自己的生命。他知道自己存在是“為了什麼”，也就知道“如何”繼續活下去。</p>
<p>我引用了尼采的話：“那沒能殺死我的，會讓我更強壯。”</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p><img src="http://i915.photobucket.com/albums/ac360/aahkan/a0765cd3.jpg" alt="意義"></p>
<h2 id="Snippet_1"><a href="#Snippet_1" class="headerlink" title="Snippet 1"></a>Snippet 1</h2><h3 id="u524D_u8A00_P-3_-_4"><a href="#u524D_u8A00_P-3_-_4" class="headerlink" title="前言 P.3 - 4"></a>前言 P.3 - 4</h3><p>生活並非弗洛伊德所宣揚的那樣，只是簡單地祈求快樂，也並非阿德勒所教導的那樣，只是為了爭權奪利。人們或者是為了尋找生命的意義，這也是人們一生中被賦予的最艱巨的使命。弗蘭克爾發現可能找尋到生命意義的三個途徑：工作（做有意義的事）、愛（關愛他人）以及擁有克服困難的勇氣。苦難本身毫無意義，但我們可以通過自身對苦難的反應賦予其意義。</p>
<p>一些不可控的力量可能會拿走你很多東西，但它唯一無法剝奪的是你自主選擇如何應對不同處境的自由。你無法控制生命中會發生什麼，但你可以控制面對這些事情時自己的情緒與行動。</p>
<h2 id="Snippet_2"><a href="#Snippet_2" class="headerlink" title="Snippet 2"></a>Snippet 2</h2><h3 id="u81EA_u5E8F_P-9"><a href="#u81EA_u5E8F_P-9" class="headerlink" title="自序 P.9"></a>自序 P.9</h3><p>不要只想著成功──你越想成功，就越容易失敗。成功就像幸福一樣，可遇而不可求。它是一種自然而然的產物，是一個人無意識地投身于某一偉大的事業時產生的衍生品，或者是為他人奉獻時的副產品。幸福總會降臨的，成功也同樣：常常是無心插柳柳成蔭。我希望你們的一切行為服從良心，并用知識去實現它。總有一天你會發現，當然是想當長的時間之後──注意，我說的是很長一段時間后！──正是由於這種不關注，成功將會降臨于你。</p>
<h2 id="Snippet_3"><a href="#Snippet_3" class="headerlink" title="Snippet 3"></a>Snippet 3</h2><h3 id="u5728_u96C6_u4E2D_u71DF_u7684_u7D93_u6B77_P-7"><a href="#u5728_u96C6_u4E2D_u71DF_u7684_u7D93_u6B77_P-7" class="headerlink" title="在集中營的經歷 P.7"></a>在集中營的經歷 P.7</h3><p>我們不喜歡談論我們的過去。對於經歷過這場噩夢的人來說，所有的解釋都是多餘的，而對於沒有這種經歷的人來說，他們不會理解我們過去的感受，也不會理解我們現在的感覺。</p>
<h2 id="Snippet_4"><a href="#Snippet_4" class="headerlink" title="Snippet 4"></a>Snippet 4</h2><h3 id="u5728_u96C6_u4E2D_u71DF_u7684_u7D93_u6B77_P-86_-_89_-_91_-_92_-_93_-_95_-_97"><a href="#u5728_u96C6_u4E2D_u71DF_u7684_u7D93_u6B77_P-86_-_89_-_91_-_92_-_93_-_95_-_97" class="headerlink" title="在集中營的經歷 P.86 - 89 - 91 - 92 - 93 - 95 - 97"></a>在集中營的經歷 P.86 - 89 - 91 - 92 - 93 - 95 - 97</h3><p>看不到未來的人之所以自甘沉淪，是因為他發現自己老在回憶。</p>
<p>對自己的未來喪失信心的犯人，註定要走向毀滅。由於他對未來失去了信念，他也就喪失了對精神的把我。他自甘墮落，成為行尸走肉。</p>
<p>一般來說，精神崩潰的犯人一開始是早上拒絕穿衣洗漱，或拒絕出操。任何勸說、任何威脅對他都不起作用。他就那麼賴在那裡，一動不動。如果這種情況是疾病引起的，他會拒絕去病號區，也拒絕做任何有助於自己恢復的事。他就那樣放棄了。他縮在自己的軀殼里，不再關心任何事情。</p>
<p>尼采說過：“知道為什麼而活的人，便能生存。”這可以作為所有心理治療師的座右銘。</p>
<p>我們真正需要的，是在生活態度上來個根本的轉變。我們需要了解自身，而且需要說服那些絕望的人：我們期望生活給予什麼并不重要，重要的是生活對我們有什麼期望。我們不應該再問生活的意義是什麼，而應該像每時每刻都被生活質問的人那樣去思考自身，我們的回答不是說與想，而是採取正確的行動。生命最終意味著承擔與接收所有的挑戰，完成自己應該完成的任務這一巨大責任。</p>
<p>這些任務（也就是生命的意義）在每個人身上，在每個時刻都是不同的，因此不可能對生命的意義作一般的定義。對生命意義的質疑，沒有唯一的答案。“生命”的意義不是某種含糊的東西，而是非常實在和具體的。它構成人的命運，而每個人的命運都是獨特的。你和你的命運無法跟任何其他人及其命運進行比較。生活永不重複，不同問題需要不同的應對。有時你發現所處的情況需要你採取行動來確定自己的命運，有時你會覺得深思熟慮更為可取，有時你會發現順其自然是正道。每種情況都有其特殊性，正確的應對也只能有一個。</p>
<p>如果你發現經受磨難是命中註定的，那你就應當把經受磨難作為自己獨特的任務。你必須承認，即使在經受磨難時，你也是獨特的、孤獨的一個人。沒有人能夠解除你的磨難，替代你的痛苦。你獨特的機會就依存于自己承受重負的方式之中。</p>
<p>這種獨特性使每個人的情況千差萬別，因此讓每個人意識到生命的意義，也就使他有可能完成其創造性的作品，享受到人類之愛。一旦他意識到自己是不可替代的，那他就會充分意識到自己的責任，也就永遠不會拋棄自己的生命。他知道自己存在是“為了什麼”，也就知道“如何”繼續活下去。</p>
<p>我引用了尼采的話：“那沒能殺死我的，會讓我更強壯。”</p>
<a id="more"></a>
<h2 id="Snippet_5"><a href="#Snippet_5" class="headerlink" title="Snippet 5"></a>Snippet 5</h2><h3 id="u5728_u96C6_u4E2D_u71DF_u7684_u7D93_u6B77_P-108"><a href="#u5728_u96C6_u4E2D_u71DF_u7684_u7D93_u6B77_P-108" class="headerlink" title="在集中營的經歷 P.108"></a>在集中營的經歷 P.108</h3><p>在這一心理階段，資質比較愚鈍的人不太容易擺脫集中營生活中司空見慣的殘忍行為的影響。獲得自由以後，他們覺得自己可以隨意而輕率地運用自己的自由了。對他們來說，唯一改變的是現在他們由被壓迫者成了壓迫者。他們是暴力和不公的施與者，而不是接受者。他們痛苦的經歷過成了為所欲為的藉口。</p>
<p>這類人慢慢地才能被引導回常識性的真理中，即誰也沒有權利為非作歹，哪怕別人曾經這樣對待你。</p>
<h2 id="Snippet_6"><a href="#Snippet_6" class="headerlink" title="Snippet 6"></a>Snippet 6</h2><h3 id="u5B58_u5728_u4E4B_u865B_u7121_P-129"><a href="#u5B58_u5728_u4E4B_u865B_u7121_P-129" class="headerlink" title="存在之虛無 P.129"></a>存在之虛無 P.129</h3><p>存在之虛無是20世紀普遍存在的現象，這也可以理解，它可能是由於人類在成為真正的人的過程中所經受的雙重喪失。在人類歷史之初，人喪失了賴以指導其行為并因此產生安全感的某些的動物本能。動物所具有的那種安全感，好比天堂一樣，對於人類來說是永遠地失去了，人類不得不做出選擇。此外，在最近時期，人類還遭受另一種喪失，那就是原本作為其行為根基的傳統迅速地消滅。喪失了告訴他必須做什麼的本能，喪失了告訴他應該做什麼的傳統，有時人甚至連自己想做什麼都不知道。這樣，他要麼去做別人所做的事（隨大流），要麼做別人希望他做的是（集權主義）。</p>
<h2 id="Snippet_7"><a href="#Snippet_7" class="headerlink" title="Snippet 7"></a>Snippet 7</h2><h3 id="u610F_u7FA9_u7642_u6CD5_P-136"><a href="#u610F_u7FA9_u7642_u6CD5_P-136" class="headerlink" title="意義療法 P.136"></a>意義療法 P.136</h3><p>人越是忘記自己──投身于某種事業或獻身于所愛的人──他就越有人性，越能實現自己的價值。所謂的自我實現，絕不是指某種可以實現的目標，因為人越是追求這個目標，越是容易失去它。換句話說，自我實現可能是自我超越唯一的副產品。</p>
<p>至此，我們已經說明生命的意義總是在變化，但作為意義永遠不會消失。按照意義療法，我們可以用三種不同的方式來發現生命之意義:</p>
<pre><code>1. 通過創立某項工作或從事某種事業；
2. 通過體驗某種事情或面對某個人；
3. 在忍受不可避免的苦難時採取某種態度。
</code></pre><h2 id="Snippet_8"><a href="#Snippet_8" class="headerlink" title="Snippet 8"></a>Snippet 8</h2><h3 id="u82E6_u96E3_u4E4B_u610F_u7FA9_P-140"><a href="#u82E6_u96E3_u4E4B_u610F_u7FA9_P-140" class="headerlink" title="苦難之意義 P.140"></a>苦難之意義 P.140</h3><p>一名年邁的、患有嚴重抑鬱症的全科醫生向我資訊，他無法接受妻子的死亡（她在兩年前去世，他愛她勝過世上的一切）。我努力克制自己，不說別的，而是對他提出這樣的一個問題：“醫生，如果你先她而去，而你太太在你死後還活著，那會怎麼樣？”“啊，”他說，“那她可就受苦了，她怎麼受得了啊！”我馬上回答：“你看醫生，她免除了這樣的痛苦，你替代了她的痛苦──當然，代價是你現在還活著，並且陷入了深深的痛苦中。”他沒再說話，搖了搖頭，悄然離開了我的辦公室。在一定意義上，一旦找到了意義（比如犧牲的意義），痛苦就不再是痛苦了。</p>
<p>在那一刻，我確實成功地改變了他對待不可改變之命運的態度，從此以後，他至少看到了自己痛苦的意義。這就是意義療法的要義之一：人主要關注的不是獲得快樂或避免苦難，而是看到其生命的意義。這也是人們為什麼甚至準備著去受苦，在這個意義上，他的痛苦有了意義。</p>
<h2 id="Snippet_9"><a href="#Snippet_9" class="headerlink" title="Snippet 9"></a>Snippet 9</h2><h3 id="u8D85_u7D1A_u610F_u7FA9_P-148"><a href="#u8D85_u7D1A_u610F_u7FA9_P-148" class="headerlink" title="超級意義 P.148"></a>超級意義 P.148</h3><p>這種終極意義必定超出了人類有限的智力範圍。在意義療法中，我們就是在這一超級意義的背景下進行陳述的。人需要做的，不是像某些存在主義哲學家所教導的那樣去忍受生命的無意義，而是忍受自己不能以合理的方式去把握生命之無限意義。意義比邏輯要深刻得多。</p>
<h2 id="Snippet_10"><a href="#Snippet_10" class="headerlink" title="Snippet 10"></a>Snippet 10</h2><h3 id="u7CBE_u795E_u75C5_u5B78_u7684_u91CD_u6B78_u4EBA_u6027_u5316_P-170__uFE63_174__uFE63_184"><a href="#u7CBE_u795E_u75C5_u5B78_u7684_u91CD_u6B78_u4EBA_u6027_u5316_P-170__uFE63_174__uFE63_184" class="headerlink" title="精神病學的重歸人性化 P.170 ﹣ 174 ﹣ 184"></a>精神病學的重歸人性化 P.170 ﹣ 174 ﹣ 184</h3><p>人不是眾多事物中的一種。事物相互決定對方，但人最終是自我決定的。他成為什麼──在天賦與環境的限度內──是他自己決定的結果。</p>
<p>應該記住的是，樂觀主義不能通過命令獲得。你甚至不能強迫自己在任何情況下對任何事情都無例外地保持樂觀。對於行為來說是這樣，對於“三位一體”中的另外兩個因素，即信任和愛也是這樣，它們也都不可能通過命令獲得。</p>
<p>在歐洲人看來，美國文化的典型特點是人們一次又一次地被命令“幸福起來”。但幸福也不是能夠強求的，它只能是結果。人們一定要有理由才能幸福起來。一旦找到了那個理由，他自然而然就會感到幸福。人類不是在追求幸福，而是通過實現內在潛藏於某種特定情況下的意義來追尋幸福的理由。</p>
<p>對這種理由的需求在人類特有的另一種現象──笑──當中同樣適用和存在。如果你想讓某人笑，那你需要給他一個笑的理由，比如講個笑話。要是你催促他笑，或讓他催促自己笑，那他無論如何是不可能真正笑起來的。若是那樣，無異於大家在照相機前齊聲說“茄子”，只會在照片上顯示出笑的模樣，但那樣的笑容是僵化而不自然的。</p>
<p>如果你不能改變造成你痛苦的處境，那你仍然可以選擇採取何種態度。</p>
<h2 id="u865F_u5916"><a href="#u865F_u5916" class="headerlink" title="號外"></a>號外</h2><p>插一句剛剛看到的話：</p>
<p>一個人命中最大的幸運，莫過於在他的人生中途，即在他年富力強的時候發現了自己生活的使命。 ──《人類群星閃耀時》</p>
]]></content:encoded>
      <comments>http://yoursite.com/2016/03/03/The%20read%20note%20about%20Man's%20Search%20For%20meaning/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[(譯)如何使用 Xcode Targets 去管理開發和生產配置]]></title>
      <link>http://yoursite.com/2016/01/26/How%20to%20use%20Xcode%20Targets/</link>
      <guid>http://yoursite.com/2016/01/26/How%20to%20use%20Xcode%20Targets/</guid>
      <pubDate>Mon, 25 Jan 2016 16:00:00 GMT</pubDate>
      <description>
      <![CDATA[<p><em>編者注釋：感謝Eugene Trapeznikov所貢獻的這篇文章。想象一下，你已經完成了你的App的開發與測試，你已經做好準備要提交產品版本了。而現在有一個問題，有一些web服務端的URL指向了測試的服務端，然後這個API鑰匙是為測試環境所配置的。在將這個App提交給Apple審核之前，你當然需要為了產品去修改所有的API鑰匙和URL，這聽起來很正確不是嗎？在來回改變開發和生產環境的值之前，有沒有一個更好的方法去處理這個問題呢？這就是Eugene將要細緻告訴你的東西。</em></p>
<p>讓我們正式進入Eugene的教程中。</p>
<p>在一開始，你們有些人可能會疑惑為什麼應該要為App開發而分別使用數據庫和生產配置。當你想繼續為你的App建立新特性或開發時，你希望分別測試開發版本和已存在的開放的App。標準軟件開發常規是為不同的版本使用不同的環境部署，在我們的例子中，就是用於iPhone App測試。同理，一個App的開發版本經常為生產環境配置使用不同的數據庫（或其他系統，比如分析系統）。這是我們為什麼為不同的環境部署使用不同的服務端或數據庫的其中一個原因。開發者們通常在測試時使用非正式的圖片或數據。在測試或開發環境中，使用測試數據比如”這是測試評論”, “argharghargh(一些亂七八糟的東西)”, “這是另一個測試評論”。你當然不希望你的真實用戶去看到這些信息。在這方面例子中，如果你的App使用分析系統，你可能在測試狀態的時候，傳送出成千上萬的事件。你同樣不想要把測試數據和產品數據混合在一個數據庫中。這就是為什麼推崇將開發和生產環境配置分離的原因。</p>
<p>當使用兩個分離的環境配置時，你的App需要知道怎麼找到那個它應該正確連接到的配置。有一種流行的方法是在你的主要app delegate中，定義一個全局變量，其來初始化你App的開發或生產模式。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">environmentType</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> development, production</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="symbol">environment:</span>environmentType = .production</span><br><span class="line"></span><br><span class="line">switch environment &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="symbol">development:</span></span><br><span class="line">    /<span class="regexp">/ set web service URL to development</span><br><span class="line">    /</span><span class="regexp">/ set API keys to development</span><br><span class="line">    print("It's for development")</span><br><span class="line">case .production:</span><br><span class="line">    /</span><span class="regexp">/ set web service URL to production</span><br><span class="line">    /</span><span class="regexp">/ set API keys to production</span><br><span class="line">    print("It's for production")</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>這個方法要求你在任何你想改變環境配置的時候，改變那個全局變量。這個方法也許快速和方便，但其有較多的局限。首先，因為我們為開發和生產環境使用單一的bundle ID，我們就不能在單一裝置中安裝兩個App版本。當你想測試開發版本時，你已經在裝置上安裝了生產版本的App，這很不方便。同時，這個方法允許在一個偶然的機會下把開發版本提交到App Store上。如果你忘記更改那個單一的全局變量，你就會把你那個錯誤的App發送給你的使用者。我就記得有一次我忘記在提交之前把這個全局變量更改了，結果使用者們得到了這個App的開發版本。這真是嚇死我了。</p>
<p>在本文中，我將告訴你一個更好的方式去區分開發和生產配置。也就是說，我們將在Xcode中創建一個開發的target。這個方法將適用於新的和已存在的大量專案，你可以使用任何一個你的App去跟隨這篇教程。</p>
<p>為適用這個方法，這個app的開發和生產配置將會擁有一樣的基本代碼，但分別使用不同的icon, bundle ID以及指向兩個數據庫。這個分配和提交過程將會非常明白。更重要的是，你的測試人員和管理人員將可以安裝兩個不同版本的App在同一個裝置中，他們完全明白哪個版本是他們要試用的。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p><em>編者注釋：感謝Eugene Trapeznikov所貢獻的這篇文章。想象一下，你已經完成了你的App的開發與測試，你已經做好準備要提交產品版本了。而現在有一個問題，有一些web服務端的URL指向了測試的服務端，然後這個API鑰匙是為測試環境所配置的。在將這個App提交給Apple審核之前，你當然需要為了產品去修改所有的API鑰匙和URL，這聽起來很正確不是嗎？在來回改變開發和生產環境的值之前，有沒有一個更好的方法去處理這個問題呢？這就是Eugene將要細緻告訴你的東西。</em></p>
<p>讓我們正式進入Eugene的教程中。</p>
<p>在一開始，你們有些人可能會疑惑為什麼應該要為App開發而分別使用數據庫和生產配置。當你想繼續為你的App建立新特性或開發時，你希望分別測試開發版本和已存在的開放的App。標準軟件開發常規是為不同的版本使用不同的環境部署，在我們的例子中，就是用於iPhone App測試。同理，一個App的開發版本經常為生產環境配置使用不同的數據庫（或其他系統，比如分析系統）。這是我們為什麼為不同的環境部署使用不同的服務端或數據庫的其中一個原因。開發者們通常在測試時使用非正式的圖片或數據。在測試或開發環境中，使用測試數據比如”這是測試評論”, “argharghargh(一些亂七八糟的東西)”, “這是另一個測試評論”。你當然不希望你的真實用戶去看到這些信息。在這方面例子中，如果你的App使用分析系統，你可能在測試狀態的時候，傳送出成千上萬的事件。你同樣不想要把測試數據和產品數據混合在一個數據庫中。這就是為什麼推崇將開發和生產環境配置分離的原因。</p>
<p>當使用兩個分離的環境配置時，你的App需要知道怎麼找到那個它應該正確連接到的配置。有一種流行的方法是在你的主要app delegate中，定義一個全局變量，其來初始化你App的開發或生產模式。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">environmentType</span> &#123;</span></span><br><span class="line">    <span class="keyword">case</span> development, production</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="symbol">environment:</span>environmentType = .production</span><br><span class="line"></span><br><span class="line">switch environment &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="symbol">development:</span></span><br><span class="line">    /<span class="regexp">/ set web service URL to development</span><br><span class="line">    /</span><span class="regexp">/ set API keys to development</span><br><span class="line">    print("It's for development")</span><br><span class="line">case .production:</span><br><span class="line">    /</span><span class="regexp">/ set web service URL to production</span><br><span class="line">    /</span><span class="regexp">/ set API keys to production</span><br><span class="line">    print("It's for production")</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>這個方法要求你在任何你想改變環境配置的時候，改變那個全局變量。這個方法也許快速和方便，但其有較多的局限。首先，因為我們為開發和生產環境使用單一的bundle ID，我們就不能在單一裝置中安裝兩個App版本。當你想測試開發版本時，你已經在裝置上安裝了生產版本的App，這很不方便。同時，這個方法允許在一個偶然的機會下把開發版本提交到App Store上。如果你忘記更改那個單一的全局變量，你就會把你那個錯誤的App發送給你的使用者。我就記得有一次我忘記在提交之前把這個全局變量更改了，結果使用者們得到了這個App的開發版本。這真是嚇死我了。</p>
<p>在本文中，我將告訴你一個更好的方式去區分開發和生產配置。也就是說，我們將在Xcode中創建一個開發的target。這個方法將適用於新的和已存在的大量專案，你可以使用任何一個你的App去跟隨這篇教程。</p>
<p>為適用這個方法，這個app的開發和生產配置將會擁有一樣的基本代碼，但分別使用不同的icon, bundle ID以及指向兩個數據庫。這個分配和提交過程將會非常明白。更重要的是，你的測試人員和管理人員將可以安裝兩個不同版本的App在同一個裝置中，他們完全明白哪個版本是他們要試用的。</p>
<a id="more"></a>
<h2 id="u5982_u4F55_u5EFA_u7ACB_u4E00_u500B_u65B0_u7684Target"><a href="#u5982_u4F55_u5EFA_u7ACB_u4E00_u500B_u65B0_u7684Target" class="headerlink" title="如何建立一個新的Target"></a>如何建立一個新的Target</h2><p>那麼如何建立一個開發target在Xcode中呢？我將通過我的模板專案”todo”帶領你一步一步走完整個流程。你也可以使用你自己的專案並且繼續整個流程:</p>
<p>1.到專案Navigator面板中，在 <em>Target</em> 區域底下，右鍵已存在的target并選擇 <code>Duplicate</code> 去複製已建立的target。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/01/Duplicate-target.png" alt="Duplicate-target"></p>
<p>2.Xcode會詢問你新的target是否要配置給iPad開發。在這個教程中，我們只選擇 “Duplicate Only”。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/01/Duplicate-only.png" alt="Duplicate-only"></p>
<pre><code>**注意：** 如果你的專案支持universal devices, Xcode將不會提示上方信息 
</code></pre><p>3.現在我們有一個新的target和一個新的叫做 <code>todo copy</code> 的scheme。我們更換它的名字使其更好理解。</p>
<ul>
<li>在 <em>TARGETS</em> 列表中選擇新的target。按下 <code>Enter</code> 編輯文字并寫入適當的名字。我推薦用 “todo Dev”，你可以選擇任何你喜歡的名字。</li>
<li>接下來，在 “Manage Schemes” 中，選擇你在第一個步驟中建立的新scheme并按下 “Enter” 并將其名字更改的和新的target一樣的名字（就是那個你選擇的新target）。</li>
</ul>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/01/Targetandscheme.png" alt="Target and scheme"></p>
<p>4.第四步可做可不做，但極力推薦你做這步。如果你想要在開發和生產配置在更簡單分辨真假數據，你應該為每個版本用不同的icon和登錄畫面。這會讓你的測試者們更明白他們在使用哪個App，並且有效防止你將開發版本推送上去。 :)</p>
<p>到 <code>Assets.xcassets</code> 中加入新的icon。右擊icon 之後選擇 App Icons &amp; Launch Images &gt; New iOS App Icon。將新的icon更名為 “AppIcon-Dev” 并加入你自己的圖片。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/01/image-asset-dev.jpg" alt="image-asset-dev"></p>
<p>5.回到專案設定中，選擇你的開發target并更改其bundle identifier。你可以在原本的ID中加入 “Dev” 字段。如果你執行了步驟4，確保你將App icon設置為上一步中所創建的那個。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/01/NewAppIDIcon.png" alt="New App ID Icon"></p>
<p>6.Xcode會自動為你的target加入一個plist檔（比如 todo copy-Info.plist）。你可以在你專案的根目錄下找到它。將其名字從”copy”改為”Dev”，并將它放在你原本的plist文件夾下。這會讓你管理文件起來更輕鬆。</p>
<p>7.打開你的開發target中的 “Build Setting”，滾到 “Packaging”，將原本的值改為開發的plist檔（例如 todo Dev.plist）。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/01/newplist.png" alt="new plist"></p>
<p>8.最後，我們會為開發和生產的target同時配置預處理的宏/編譯器的標誌。我們將使用這個標誌以告訴自己現在什麼版本的App是正在運行中的。</p>
<p>如果是Objective-C專案，到 <code>Build Settings</code> 并滾到 <code>Apple LLVM 7.0 - Preprocessing</code> ，展開 <code>Preprocessor Macros</code> 并分別為 <em>Debug</em> 和 <em>Release</em> 域中加入一個變數。 在開發target中(例如 todo Dev)， 將其值設置為 <code>DEVELOPMENT=1</code>. 在另一邊, 將值設置為 <code>DEVELOPMENT=0</code> 以表明其為生產的版本。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/01/dev-macro-1-1.png" alt="dev-macro-1"></p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/01/dev-macro-2-1.png" alt="dev-macro-2"></p>
<p>在Swift專案中，編譯器不再支持預處理的指令。以代替的是編譯時(complie-time)屬性和構建配置。我們將選擇開發的target，加入一個標誌以表明其為開發的構建。到 <code>Bulid Settings</code> 中并滾到 <code>Swift Compiler - Custom Flags</code> 區域中，將值設置為 <code>-DDEVELOPMENT</code> 以表明其target將在開發的構建中使用。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/01/swift-compiler-flag.png" alt="swift-compiler-flag"></p>
<p>現在你建立并配置了開發的target，下一步呢？</p>
<h2 id="u4F7F_u7528Target_u548C_u5B8F"><a href="#u4F7F_u7528Target_u548C_u5B8F" class="headerlink" title="使用Target和宏"></a>使用Target和宏</h2><p>我們可以在代碼中利用 <code>DEV_VERSION</code> 的宏配置并在專案中執行動態編譯，舉例來說：</p>
<p><strong>Objective-C:</strong></p>
<pre lang="swift">
#if DEVELOPMENT
#define SERVER_URL @"http://dev.server.com/api/"
#define API_TOKEN @"DI2023409jf90ew"
#else
#define SERVER_URL @"http://prod.server.com/api/"
#define API_TOKEN @"71a629j0f090232"
#endif
</pre>

<p>在Objective-C中，你可以使用 <code>#if</code> 去檢查 <code>DEV_VERSION</code> 的狀態，并以此設置URL與API的鑰匙。</p>
<p><strong>Swift:</strong></p>
<pre lang="swift">
#if DEVELOPMENT
let SERVER_URL = "http://dev.server.com/api/"
let API_TOKEN = "DI2023409jf90ew"
#else
let SERVER_URL = "http://prod.server.com/api/"
let API_TOKEN = "71a629j0f090232"
#endif
</pre>

<p>在Swift中，你依舊使用 <code>#if</code> 為動態編譯分析當前構建的配置是哪個。但是，以代替使用 <code>#define</code> 而去使用一個原始的常數，我們將在Swift中使用 <code>let</code> 去定義全域常數。</p>
<pre><code>**注意:** 通常，你會將以上代碼放入一個pp協定中，但它其實依賴於你在哪裡初始化這個App的設置中。
</code></pre><p>現在當你選擇 “todo Dev” schem并運行專案，你將會自動地依照服務端配置建立開發構建以設置開發環境。你現在已經為你的測試者和管理者準備好上傳開發版本到TestFlight 或 HockeyApp中了。</p>
<p>之後如果你需要建立一個生產構建，你只要選擇 “todo” scheme即可，沒有任何代碼再需要更改了。</p>
<h2 id="u4E00_u4E9B_u95DC_u65BC_u7BA1_u7406_u591A_u500BTarget_u7684_u6CE8_u610F_u4E8B_u9805"><a href="#u4E00_u4E9B_u95DC_u65BC_u7BA1_u7406_u591A_u500BTarget_u7684_u6CE8_u610F_u4E8B_u9805" class="headerlink" title="一些關於管理多個Target的注意事項"></a>一些關於管理多個Target的注意事項</h2><p>1.別忘記當你把一些新的文件加入專案時，選擇多個target以使其同步發生在兩種構建中。</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2016/01/add-new-file.png" alt="add-new-file"></p>
<p>2.如果你使用 Cocoapods，別忘記將新的target加入到你的podfile中。你可以使用 <code>link_with</code> 以指定多個target。你可以在 <a href="https://guides.cocoapods.org" target="_blank" rel="external">Cocoapods documentation</a> 中進一步了解詳細資訊。你的podfile可能會像這樣：</p>
<pre>source 'https://github.com/CocoaPods/Specs.git'
platform :ios, '7.0'
workspace 'todo'
link_with 'todo', 'todo Dev'
pod 'Mixpanel'
pod 'AFNetworking'
</pre>

<p>3.如果你使用持續集合系統(continuous integration system)，例如<a href="https://travis-ci.org" target="_blank" rel="external">Travis CI</a> 或 <a href="https://jenkins-ci.org" target="_blank" rel="external">Jenkins</a> ，別忘記為兩個target配置構建。</p>
<p>你認為這次的教程效果如何呢？你又是怎麼管理你的開發和生產構建的呢？留下你的評論并分享你的想法吧。</p>
<p>原文鏈接: <a href="http://www.appcoda.com/using-xcode-targets/" target="_blank" rel="external">http://www.appcoda.com/using-xcode-targets/</a></p>
<h2>譯者介紹</h2>

<p>謝岳庭，中文系出身，自學iOS開發，有著异於常人的求知慾。</p>
<p>你可以在Twitter或<a href="http://www.appcoda.com.tw/forum/" target="_blank" rel="external">AppCoda討論區</a>中聯繫我并隨時歡迎你與我交流。</p>
<p>My Twitter: <a href="https://twitter.com/Lanaya_HSIEH" target="_blank" rel="external">@Lanaya_HSIEH</a></p>
<p>My Blog: <a href="http://yuejun1991.github.io" target="_blank" rel="external">Less complaing, More thinking</a></p>
]]></content:encoded>
      <comments>http://yoursite.com/2016/01/26/How%20to%20use%20Xcode%20Targets/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[(譯)iOS Cell Registration & Reusing with Swift Protocol Extensions and Generics]]></title>
      <link>http://yoursite.com/2016/01/17/iOS%20Cell%20Registration%20&%20Reusing%20with%20Swift%20Protocol%20Extensions%20and%20Generics/</link>
      <guid>http://yoursite.com/2016/01/17/iOS%20Cell%20Registration%20&%20Reusing%20with%20Swift%20Protocol%20Extensions%20and%20Generics/</guid>
      <pubDate>Sat, 16 Jan 2016 16:00:00 GMT</pubDate>
      <description>
      <![CDATA[<p>如果你使用Storyboards的話，你應該會經常碰到這些情形：為UITableView和UIColloectionView註冊(register)自定義的cell。</p>
<p>UITableView和UICollectionView提供我們一組非常相似的API來註冊自定義的cell:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">registerClass</span><span class="params">(cellClass: AnyClass?, forCellWithReuseIdentifier identifier: String)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">registerNib</span><span class="params">(nib: UINib?, forCellWithReuseIdentifier identifier: String)</span></span></span><br></pre></td></tr></table></figure>
<p>一種被廣泛使用來處理註冊和出列的處理方法是為reuse identifier(複用識別)宣告一個常數:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> reuseIdentifier = <span class="string">"BookCell"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListViewController</span>: <span class="title">UIViewController</span>, <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBOutlet</span> <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> nib = <span class="type">UINib</span>(nibName: <span class="string">"BookCell"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">self</span>.collectionView.registerNib(nib, forCellWithReuseIdentifier: reuseIdentifier)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCellWithReuseIdentifier(reuseIdentifier, forIndexPath: indexPath)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> bookCell = cell <span class="keyword">as</span>? <span class="type">BookCell</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> configure cell</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">  	  &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>讓我們來嘗試概括一下這段code以及讓它變得更簡單和安全吧。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p>如果你使用Storyboards的話，你應該會經常碰到這些情形：為UITableView和UIColloectionView註冊(register)自定義的cell。</p>
<p>UITableView和UICollectionView提供我們一組非常相似的API來註冊自定義的cell:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">registerClass</span><span class="params">(cellClass: AnyClass?, forCellWithReuseIdentifier identifier: String)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">registerNib</span><span class="params">(nib: UINib?, forCellWithReuseIdentifier identifier: String)</span></span></span><br></pre></td></tr></table></figure>
<p>一種被廣泛使用來處理註冊和出列的處理方法是為reuse identifier(複用識別)宣告一個常數:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> reuseIdentifier = <span class="string">"BookCell"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListViewController</span>: <span class="title">UIViewController</span>, <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">@IBOutlet</span> <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> nib = <span class="type">UINib</span>(nibName: <span class="string">"BookCell"</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">self</span>.collectionView.registerNib(nib, forCellWithReuseIdentifier: reuseIdentifier)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cell = collectionView.dequeueReusableCellWithReuseIdentifier(reuseIdentifier, forIndexPath: indexPath)</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> bookCell = cell <span class="keyword">as</span>? <span class="type">BookCell</span> &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> configure cell</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">  	  &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>讓我們來嘗試概括一下這段code以及讓它變得更簡單和安全吧。</p>
<a id="more"></a>
<p>首先，把我們的App中每一個的reuse identifier提取出來。這樣我們只能使用自定義cell類中的名字來作為一個缺省的reuse identifier。</p>
<p>我們可以為Reuseable Views創建一個協議(protocol)並且為UIView的子類提供一個缺省的實現限制。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ReusableView</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultReuseIdentifier: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ReusableView</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"> 	 <span class="keyword">static</span> <span class="keyword">var</span> defaultReuseIdentifier: <span class="type">String</span> &#123;</span><br><span class="line"> 	       <span class="keyword">return</span> <span class="type">NSStringFromClass</span>(<span class="keyword">self</span>)</span><br><span class="line">  	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UICollectionViewCell</span>: <span class="title">ReusableView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然後讓UICollectionViewCell遵從ReusableView協議，就可以給每一個cell的子類別一個獨一無二的reuse identifier了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let identifier = BookCell<span class="class">.defaultReuseIdentifier</span></span><br><span class="line"><span class="comment">// identifier = "MyModule.BookCell"</span></span><br></pre></td></tr></table></figure>
<p>接下來我們使用加載Nib的方式來擺脫麻煩的編寫字串(hard-coded string)。</p>
<p>我們繼續為Nib Loadable Views創建一個協議，並且為擴展協議的範圍提供一個缺省值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NibLoadableView</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nibName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NibLoadableView</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nibName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NSStringFromClass</span>(<span class="keyword">self</span>).componentsSeparatedByString(<span class="string">"."</span>).last!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BookCell</span>: <span class="title">NibLoadableView</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通過讓BookCell類遵從NIbLoadableView協議，我們現在有一個很安全的方式取得Nib的名字了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let nibName = BookCell<span class="class">.nibName</span></span><br><span class="line"><span class="comment">// nibName = "BookCell"</span></span><br></pre></td></tr></table></figure>
<p>如果你使用一個來自XIB文件的不一樣的名字，而不是Xcode本身提供的，你永遠可以覆寫(override)nibName屬性的缺省值。</p>
<p>有了這兩個協議之後，我們就可以使用Swift的泛型去擴展UICollectionView，達到更簡單註冊和出列cell。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UICollectionView</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">register</span><span class="generics">&lt;T: UICollectionViewCell where T: ReusableView&gt;</span><span class="params">(<span class="number">_</span>: T.<span class="keyword">Type</span>)</span></span> &#123;</span><br><span class="line">        registerClass(<span class="type">T</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="type">T</span>.defaultReuseIdentifier)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">register</span><span class="generics">&lt;T: UICollectionViewCell where T: ReusableView, T: NibLoadableView&gt;</span><span class="params">(<span class="number">_</span>: T.<span class="keyword">Type</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bundle = <span class="type">NSBundle</span>(forClass: <span class="type">T</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> nib = <span class="type">UINib</span>(nibName: <span class="type">T</span>.nibName, bundle: bundle)</span><br><span class="line">        </span><br><span class="line">        registerNib(nib, forCellWithReuseIdentifier: <span class="type">T</span>.defaultReuseIdentifier)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dequeueReusableCell</span><span class="generics">&lt;T: UICollectionViewCell where T: ReusableView&gt;</span><span class="params">(forIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> cell = dequeueReusableCellWithReuseIdentifier(<span class="type">T</span>.defaultReuseIdentifier, forIndexPath: indexPath) <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Could not dequeue cell with identifier: <span class="subst">\(T.defaultReuseIdentifier)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>請注意，我們創建了兩個變化的register方法，一個是實現cell的子類別ReusableView，一個則可以通用於ReuseableView和NibLoadableView。這是非常適合對單獨的view controller用於特定的cell註冊方法(<strong>This nicely decouples the view controller from the specific cell registration method</strong>)。</p>
<p>另外一個好的細節在於dequeueReusableCell方法不需要去使用任何復用的識別碼，而只需要對其回傳的值使用cell的子類別。</p>
<p>現在cell的註冊和出列看起來會更加出色了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListViewController</span>: <span class="title">UIViewController</span>, <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.collectionView.register(<span class="type">BookCell</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cell: <span class="type">BookCell</span> = collectionView.dequeueReusableCell(forIndexPath: indexPath)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> configure cell</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7D50_u5C3E"><a href="#u7D50_u5C3E" class="headerlink" title="結尾"></a>結尾</h2><p>如果你之前學習過Objective-C，去研究Swift的強大的特性比如擴展協定和泛型的特性，以找到更多選擇和更優雅的方式去處理Cocoa類。</p>
<hr>
<p>本文以獲得原作者的翻譯許可。</p>
<h5 id="u5982_u6709_u7FFB_u8B6F_u4E0D_u8DB3_u4E4B_u8655_uFF0C_u8ACB_u591A_u591A_u5305_u542B_u8207_u6307_u6559_u3002"><a href="#u5982_u6709_u7FFB_u8B6F_u4E0D_u8DB3_u4E4B_u8655_uFF0C_u8ACB_u591A_u591A_u5305_u542B_u8207_u6307_u6559_u3002" class="headerlink" title="如有翻譯不足之處，請多多包含與指教。"></a>如有翻譯不足之處，請多多包含與指教。</h5><p><a href="https://medium.com/@gonzalezreal/ios-cell-registration-reusing-with-swift-protocol-extensions-and-generics-c5ac4fb5b75e#.jnkx73nhv" target="_blank" rel="external">原文地址在此</a></p>
]]></content:encoded>
      <comments>http://yoursite.com/2016/01/17/iOS%20Cell%20Registration%20&%20Reusing%20with%20Swift%20Protocol%20Extensions%20and%20Generics/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[(譯)如何在iOS 9中使用Core Spotlight框架]]></title>
      <link>http://yoursite.com/2016/01/15/How%20to%20use%20Core%20Spotlight%20framework%20in%20iOS%209/</link>
      <guid>http://yoursite.com/2016/01/15/How%20to%20use%20Core%20Spotlight%20framework%20in%20iOS%209/</guid>
      <pubDate>Thu, 14 Jan 2016 16:00:00 GMT</pubDate>
      <description>
      <![CDATA[<h3 id="u672C_u6587_u70BAHow_to_Use_Core_Spotlight_Framework_in_iOS_9_u7684_u7FFB_u8B6F"><a href="#u672C_u6587_u70BAHow_to_Use_Core_Spotlight_Framework_in_iOS_9_u7684_u7FFB_u8B6F" class="headerlink" title="本文為How to Use Core Spotlight Framework in iOS 9的翻譯"></a>本文為<a href="http://www.appcoda.com/core-spotlight-framework/">How to Use Core Spotlight Framework in iOS 9</a>的翻譯</h3><p>每一次新iOS版本的到來都會帶給全世界所有的開發者們新“東西”并進階已存在的技術。無疑，最新的版本iOS 9，也不會置身于這個傳統之外。開發者們再一次有了新的框架與API以讓他們的App獲得更高水平。其中一個新東西就是 <strong>Core Spotlight</strong> 框架，它靜靜地等待在那邊讓開發者們使用它新的API。</p>
<p>Core Spotlight(CS)框架，是更大型API的集合，以 <em>Search APIs</em> 聞名，這給了開發者們機會去顯著提高他們App被訪問的可發現性，可見性和易用性，這是在以前iOS版本中完全不可能被做到的。Search APIs讓使用者與開發者的聯繫更加緊密，前者可以以更新更快的方式來到達後者的App，後者也可以從前者那獲得更多更迅速的響應。除了Core Spotlight，還有其他新的搜索特性包括在iOS 9中（這裡只是做個介紹）：</p>
<ol><br><li>新的方法和屬性存在與 <em>NSUserActivity</em> 類中（這是用來負責存儲App狀態以為了能讓App在稍後的時間里恢復）。</li><br><li><em>web markup</em> 是用來讓網頁在裝置中被搜索到。</li><br><li><em>universal links</em> 是讓App在網頁鏈接中被直接啟動。</li><br></ol>

<p>我們不會全部處理上述所說的三個方面，而我們將會看到對於Core Spotlight框架的細節。在那之前，我們需要介紹一下這個框架。</p>
<p><img alt="core-spotlight-framework" src="http://www.appcoda.com/wp-content/uploads/2015/12/core-spotlight-framework.jpg"/></p>
<p><a href="https://developer.apple.com/library/ios/documentation/CoreSpotlight/Reference/CoreSpotlight_Framework/">Core Spotlight framework</a> 讓App中的數據 <em>可搜索化</em> ，以及隨後對於系統反饋的搜索結果回傳到App，并在其中打開。這讓使用者可以在第一時間從應用中搜尋到數據（而以前只能搜索到Apple原生的應用的資訊），並且相互作用，這是相當令人印象深刻的變革。按說用戶可以與相關的自定義應用的搜索結果進行互動，而我的意思是，不僅應用程序將因為搜索結果記錄而自動啟動，開發者也同時將用戶吸引到特定視圖控制器(specific view controllers)，這些最合適最恰當的數據就顯示在Spotlight中。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<h3 id="u672C_u6587_u70BAHow_to_Use_Core_Spotlight_Framework_in_iOS_9_u7684_u7FFB_u8B6F"><a href="#u672C_u6587_u70BAHow_to_Use_Core_Spotlight_Framework_in_iOS_9_u7684_u7FFB_u8B6F" class="headerlink" title="本文為How to Use Core Spotlight Framework in iOS 9的翻譯"></a>本文為<a href="http://www.appcoda.com/core-spotlight-framework/" target="_blank" rel="external">How to Use Core Spotlight Framework in iOS 9</a>的翻譯</h3><p>每一次新iOS版本的到來都會帶給全世界所有的開發者們新“東西”并進階已存在的技術。無疑，最新的版本iOS 9，也不會置身于這個傳統之外。開發者們再一次有了新的框架與API以讓他們的App獲得更高水平。其中一個新東西就是 <strong>Core Spotlight</strong> 框架，它靜靜地等待在那邊讓開發者們使用它新的API。</p>
<p>Core Spotlight(CS)框架，是更大型API的集合，以 <em>Search APIs</em> 聞名，這給了開發者們機會去顯著提高他們App被訪問的可發現性，可見性和易用性，這是在以前iOS版本中完全不可能被做到的。Search APIs讓使用者與開發者的聯繫更加緊密，前者可以以更新更快的方式來到達後者的App，後者也可以從前者那獲得更多更迅速的響應。除了Core Spotlight，還有其他新的搜索特性包括在iOS 9中（這裡只是做個介紹）：</p>
<ol><br><li>新的方法和屬性存在與 <em>NSUserActivity</em> 類中（這是用來負責存儲App狀態以為了能讓App在稍後的時間里恢復）。</li><br><li><em>web markup</em> 是用來讓網頁在裝置中被搜索到。</li><br><li><em>universal links</em> 是讓App在網頁鏈接中被直接啟動。</li><br></ol>

<p>我們不會全部處理上述所說的三個方面，而我們將會看到對於Core Spotlight框架的細節。在那之前，我們需要介紹一下這個框架。</p>
<p><img alt="core-spotlight-framework" src="http://www.appcoda.com/wp-content/uploads/2015/12/core-spotlight-framework.jpg"></p>
<p><a href="https://developer.apple.com/library/ios/documentation/CoreSpotlight/Reference/CoreSpotlight_Framework/" target="_blank" rel="external">Core Spotlight framework</a> 讓App中的數據 <em>可搜索化</em> ，以及隨後對於系統反饋的搜索結果回傳到App，并在其中打開。這讓使用者可以在第一時間從應用中搜尋到數據（而以前只能搜索到Apple原生的應用的資訊），並且相互作用，這是相當令人印象深刻的變革。按說用戶可以與相關的自定義應用的搜索結果進行互動，而我的意思是，不僅應用程序將因為搜索結果記錄而自動啟動，開發者也同時將用戶吸引到特定視圖控制器(specific view controllers)，這些最合適最恰當的數據就顯示在Spotlight中。</p>
<a id="more"></a>
<p>其實以開發者的角度來看，結合Core Spotlight框架，並使用其提供的API并不是一個複雜的過程。你即將會發現在本教程中中，需要做到的代碼只有幾行。這其中的核心部份是讓開發者去“告知”iOS關於應用數據的 <em>索引(index)</em> 。</p>
<p>正因本次教程是Core Spotlight框架專屬的，我并不打算在本次介紹中深入其他細節。如果你樂於研究其中是如何實現一些東西的我個人是十分高興的，也請你繼續閱讀下去。我保證你在閱讀到最後會十分滿意這是如何簡單讓你的應用能夠在Spotlight中被識別。</p>
<h2>關於範例App</h2>

<p>我們將一如既往的通過使用一個範例應用來深入了解我們所提到的話題中的細節。在這裡，我們將放置一些數據集合到這個應用中，然後這些數據會被裝置（或模擬器）中的Spotlight所搜尋到。但是首先，我們必須要先來了解一下我們這個應用的一些細節。</p>
<p>這個範例是去展示一些 <em>電影</em> 資訊，比如其摘要，導演，明星陣容，評級等等。所有這些電影資訊會被放置在一個tableview中，當按下其中一列時，某部電影的細節資訊將會被展示在一個新的view controller中。就是這樣，這些東西就可以讓我們可以看到Core Spotlight的API是如何運作的。另外供你參考，我們數據中的這些資源是來自 <em><a href="http://www.imdb.com" target="_blank" rel="external">International Movie Database (IMDB)</a></em> 。我是從這個地方取得樣品數據的。</p>
<p>你可以通過以下動畫來對我們的範例App有一個第一印象。</p>
<p><img alt="Core Spotlight Demo" src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_1_app_working-compressor.gif"></p>
<p>我們在這個教程中有兩個目標。最重要的一個就是讓所有包含在應用中的電影數據可以被Spotlight中搜尋到，然後，使用者會在Spotlight中輸入一些關鍵字來查詢到我們應用中的電影資訊並且展示給他們看。我們的任務與責任就是去決定并設置這些關鍵字。</p>
<p>通過按下一個電影的搜索結果，應用將會被打開，然後我們的第二個目標來了。如果我們沒有進行任何動作，默認的view controller會被加載並且顯示給使用者看，就是那個tableview包含了全部的電影列表的view controller。但這個使用者體驗聽起來並不太妙。一個更好的做法是，我們的應用應該展示那個在Spotlight中被選擇的電影細節，而這也是我們最終要做的。總之，我們不僅會讓我們的電影數據在Spotlight中被搜索到，同時也會當Spotlight中的項目被點擊時在應用中展示相關的細節。以下例子會讓這些更清楚一點：</p>
<p><img alt="Core Spotlight Final Demo" src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_2_final_sample-compressor.gif"></p>
<p>為了不要浪費更多的時間，你可以<a href="https://www.dropbox.com/s/2oge5z8q7u4r11m/SpotItStarter.zip?dl=0" target="_blank" rel="external">在這裡下載一個project</a>。你會在裡面看到這些東西：</p>
<ul><br><li>UI的部份通過所有必要的IBOutlet屬性已經被做好了。</li><br><li>對tableview的一個最小實現。</li><br><li>所有的電影數據都存在于一個.plist文件中。另外，還有一些圖片用來搭配對應的電影（一共5個）。</li><br></ul>

<p>你可能想知道這個列表的電影數據屬性是屬於什麼類別的，你可以通過以下一個屏幕截圖來了解到這些信息：</p>
<p><img alt="t46_3_movie_plist_sample" src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_3_movie_plist_sample.png"></p>
<p>我們將會在看到Core Spotlight API的更多細節之前，先做兩個不同的任務：</p>
<ol><br><li>我們先要載入和放置電影數據到tableview中。</li><br><li>我們將展示一個被選擇的電影資訊到detail view controller中。</li><br></ol>

<p>我并沒有在起始項目中實現上述任務，即使這會讓我們更快進入這方面的話題，原因是：我非常自信通過了解這個範例應用和樣品的數據，會讓你有更多的對於具體數據是如何被Spotlight所搜索到有更多的認識。不用擔心，前期工作不多，可以做的很快。</p>
<h2>加載和展示樣品的數據</h2>

<p>如果你已經下載好了起始項目并看了關於電影數據的plist檔，我們就開始吧。在 <em>MoviesData.plist</em> 文件中你會發現一共有5個入口，每一個樣品電影都是隨機在IMDB網站上取得的。我們的第一個任務是從.plist檔中加載數據到一個array里，然後把array放進tableview</p>
<p>直接進入代碼里，打開 <em>ViewController.swift</em> 檔，這個我們主要運用到的文件，然後在class裡面的最上方宣告以下屬性：</p>
<pre lang="swift">var moviesInfo: NSMutableArray!
</pre>

<p>所有電影都會被加載進這個array中，每一個電影都會以存在于屬性列表文件中的屬性來代表成一個dictionary，裡面包含了keys和values.</p>
<p>讓我們先寫一個小型自定義方法，在該方法里，將會進行數據加載。我們首先確保這個屬性列表文件是存在的，如此之後，我們才在這個array中初始化文件中的內容：</p>
<pre lang="swift">func loadMoviesInfo() {
    if let path = NSBundle.mainBundle().pathForResource("MoviesData", ofType: "plist") {
        moviesInfo = NSMutableArray(contentsOfFile: path)
    }
}
</pre>

<p>接下來，我們必須在 <em>viewDidLoad()</em> 方法中呼叫它。你必須確保這個呼叫必須在 <em>configureTableView()</em> 方法發生之前：</p>
<pre lang="swift">override func viewDidLoad() {
    super.viewDidLoad()

    // Load the movies data from the file.
    loadMoviesInfo()

    configureTableView()
    navigationItem.title = "Movies"
}
</pre>

<p>注意以上創建的自定義方法當然可以寫在 <em>viewDidLoad()</em> 中，但是為了有整潔的代碼風格，我們這種方式可以讓代碼變得更輕更好。</p>
<p>你應該知道電影數據要在應用啟動前被加載，然後我們才能夠繼續將當前的tableview實例化去展示我們的電影數據。這裡不會再做其他事情了。我們將會依據電影來決定列的數量，然後將屬性數據展示在tableview的cell上。</p>
<p>很明顯的，列的數量應該是和電影的數量相等的。但是，我們應該不應該忘記首先需要去保證確實存在可展示的電影，不然整個應用將會瞬間崩潰，因為在這種情況下文件內容不會被加載到array中。</p>
<pre lang="swift">func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
    if moviesInfo != nil {
        return moviesInfo.count
    }

    return 0
}
</pre>

<p>最後，讓我們將這些電影數據展示出來。在這個範例應用的起始項目上，你可以找到一個屬於 <em>UITableViewCell</em> 類的子類叫做 <em>MovieSummaryCell</em> ，以及對應的 <em>.xib</em> 檔去表示單個電影cell：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_4_custom_cell_ib.png" alt="t46_4_custom_cell_ib" class="aligncenter size-full wp-image-6868"></p>
<p>每一個cell都會展示出圖片，標題，描述的部份以及每一部電影的評價。所有的UI控制器都已經和IBOutlet屬性連接，你可以在 <em>MovieSummaryCell.swift</em> 檔中找到他們。</p>
<pre lang="swift">@IBOutlet weak var imgMovieImage: UIImageView!

@IBOutlet weak var lblTitle: UILabel!

@IBOutlet weak var lblDescription: UILabel!

@IBOutlet weak var lblRating: UILabel!
</pre>

<p>上述名稱都暗示了每個屬性的目的。既然我們已經看到了他們，那我們就開始讓他們與我們電影的細節關聯上吧。回到 <em>ViewController.swift</em> 中，通過接下來的程式碼來更新tableview中的方法：</p>
<pre lang="swift">func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
    let cell = tableView.dequeueReusableCellWithIdentifier("idCellMovieSummary", forIndexPath: indexPath) as! MovieSummaryCell

    let currentMovieInfo = moviesInfo[indexPath.row] as! [String: String]

    cell.lblTitle.text = currentMovieInfo["Title"]!
    cell.lblDescription.text = currentMovieInfo["Description"]!
    cell.lblRating.text = currentMovieInfo["Rating"]!
    cell.imgMovieImage.image = UIImage(named:     currentMovieInfo["Image"]!)

    return cell

}
</pre>

<p>對於 <em>currentMovieInfo</em> 字典的使用並非是必須的，然而這讓整個程式碼看起來清晰易讀。</p>
<p>你可以先執行一次這個應用，你會看到電影的細節都被tableview所監聽到。到目前為止我們都做了大家很熟悉的東西，現在讓我們直接進入第二預備步驟：將電影的細節部份展示出來。</p>
<h2>展示數據細節</h2>

<p>我們將在 <em>MovieDetailsViewController</em> 類中展示每一個從屬於 <em>ViewController</em> 類的tableview中被選擇的電影的細節。各自的場景都已經在Interface Builder中存在了，所以我們將做兩件事情：從 <em>ViewController</em> 傳遞合適的電影字典到這個類中，然後放置那些字典裡面的值到合適的UI控制器上，就是那些你能看到的所有的已經被宣告和連接的IBOutlet屬性。</p>
<p>為了與字典進行對話，讓我們接下來在 <em>MovieDetailsViewController</em> 類內面的最上方做一個宣告：</p>
<pre lang="swift">var movieInfo: [String: String]!
</pre>

<p>讓我們馬上回到 <em>ViewController</em> 檔中，去看看我們接下來當電影列被觸發時應該做什麼。當這件事情發生時，我們想要知道是哪一個列被按下。我們從 <em>moviesInfo</em> 陣列中挑選合適的字典傳遞到下一個view controller上，同時，一個叫做 <em>idSegueShowMovieDetails</em> 的segue將會被執行。取得該列的索引並不麻煩，我們只需要一個自定義的屬性來存放它就好了。因此我們在 <em>ViewController</em> 類里還需要宣告這個：</p>
<pre lang="swift">var selectedMovieIndex: Int!
</pre>

<p>然後，我們需要去處理tableview中的列被選擇時需要執行的方法：</p>
<pre lang="swift">func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
    selectedMovieIndex = indexPath.row
    performSegueWithIdentifier("idSegueShowMovieDetails", sender: self)
}
</pre>

<p>我們一共做了兩件簡單的事情：我們先在我們自己的屬性中，儲存了被按下的列的索引，然後執行segue去讓我們的電影細節被展示出來。但這還不夠，我們還沒從 <em>moviesInfo</em> 陣列中挑選合適的電影字典，我們也沒有傳遞任何東西到 <em>MovieDetailsViewController</em> 中。我們應該怎麼做？答案是去覆寫 <em>prepareForSegue:sender:</em> 方法然後做我剛剛說的事情，我們看看是怎麼做到的：</p>
<pre lang="swift">override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
    if let identifier = segue.identifier {
        if identifier == "idSegueShowMovieDetails" {
            let movieDetailsViewController = segue.destinationViewController as! MovieDetailsViewController
            movieDetailsViewController.movieInfo = moviesInfo[selectedMovieIndex] as! [String : String]
        }
    }
}
</pre>

<p>這很簡單，我們通過segue的屬性  <em>destinationViewController</em> 取得到了 <em>MovieDetailsViewController</em> 的實例變量，然後我們將合適的電影字典分配到了剛剛在這部份開始宣告的屬性 <em>movieInfo</em> 上。</p>
<p>現在，再一次打開 <em>MovieDetailsViewController.swift</em> 檔，我們只要宣告一個自定的方法。在這方面里，我們將從 <em>movieInfo</em> 字典中分配合適的值到合適的UI控制器中，然後這一部份就基本告一段落了。這下面的代碼實現并不複雜，所以我不做其他解釋了：</p>
<pre lang="swift">func populateMovieInfo() {
    lblTitle.text = movieInfo["Title"]!
    lblCategory.text = movieInfo["Category"]!
    lblDescription.text = movieInfo["Description"]!
    lblDirector.text = movieInfo["Director"]!
    lblStars.text = movieInfo["Stars"]!
    lblRating.text = movieInfo["Rating"]!
    imgMovieImage.image = UIImage(named: movieInfo["Image"]!)
}
</pre>

<p>隨後，在 <em>viewWillAppear:</em> 方法中呼叫上述方法就好啦：</p>
<pre lang="swift">override func viewWillAppear(animated: Bool) {
    ...

    if movieInfo != nil {
            populateMovieInfo()
    }
}
</pre>

<p>這部份又告一段落啦，你可以再試一次這個App，然後去看看你從tableview中選擇的每一個電影細節吧。</p>
<h2>對於Spotlight的索引數據</h2>

<p>通過使用iOS 9中的Core Spotlight框架，任何一個應用的數據都可以通過Spotlight被搜索到。關鍵就是從Core Spotlight的API中特別詢問我們數據的 <em>索引</em> 是什麼，這樣數據就可以給使用者正確地尋找到了。但是我們的應用中，都還沒有讓我們的數據去使用CS API。我們需要去為我們的數據以特別的方式準備和提供那些API。</p>
<p>說的更清楚一點，那些我們想要通過Spotlight被搜尋到的數據都必須在 <em>CSSearchableItem</em> 物件中被描述出來，然後將它們以陣列的方式組合并用CS API做出索引。 單一 <em>CSSearchableItem</em> 物件包含了一些屬性讓iOS以更快更乾淨的方式來找到每一個能被搜尋的項目，比如說什麼數據應該在搜索的時候被展示出來（例如電影的名字，它的圖片和描述），還有是什麼關鍵字導致我們應用中的數據被Spotlight搜尋到之類。所有這些屬性都包含在一個叫做 <em>CSSearchableItemAttributeSet</em> 的物件中，它可以提供許多屬性讓我們去分配我們需要的值。如果你需要，我給你<a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreSpotlight/Reference/CSSearchableItemAttributeSet_Class/index.html" target="_blank" rel="external">官方文檔鏈接</a>，這樣你就可以看到所有被支持的屬性啦。</p>
<p>為Spotlight中的數據設置索引是最後才要做的事情。通常來說按照以下流程：</p>
<ol><br><li>為每一段數據設置它們獨有的屬性，比如一個電影。（ <em>CSSearchableItemAttributeSet</em> ）</li><br><li>用之前的屬性為每一段數據初始化一個可被搜索的項目。（ <em>CSSearchableItem</em> ）</li><br><li>把這些可被搜索的項目都放入一個陣列中。</li><br><li>為陣列中的每一個項目設置一個索引。</li><br></ol>

<p>我們將一步一步來。為了完成我們的目的，我們將在 <em>ViewController.swift</em> 檔中創立一個叫做 <em>setupSearchableContent()</em> 的自定義方法。在我們這部份最後的實例變量中你會發現讓你的數據變得可搜索化並不難。但是我們不會直接把整個方法一次實現。我會將代碼進行拆解，讓你可以足夠簡單地消化下去。這一點也不多。</p>
<p>在我們實現我們的方法之前，我們必須先import兩個框架：</p>
<pre lang="swift">import CoreSpotlight
import MobileCoreServices
</pre>

<p>我們可以開始給我們的新方法下定義了。在方法開始宣告一個用來收集可搜索化項目的集合：</p>
<pre lang="swift">func setupSearchableContent() {
    var searchableItems = [CSSearchableItem]()
}
</pre>

<p>在迴圈中我們開始分配每一個電影：</p>
<pre lang="swift">func setupSearchableContent() {
    var searchableItems = [CSSearchableItem]()

    for i in 0...(moviesInfo.count - 1) {
        let movie = moviesInfo[i] as! [String: String]
    }
}
</pre>

<p>對每個電影，我們都會創建一個 <em>CSSearchableItemAttributeSet</em> 物件，然後設置那些當在Spotlight被搜索時，我們想展示出來的搜索結果的屬性。在我們的範例中，我們會明確出電影的標題，描述和圖片來作為我們想給使用者看到的數據片段。</p>
<pre lang="swift">func setupSearchableContent() {
    var searchableItems = [CSSearchableItem]()

    for i in 0...(moviesInfo.count - 1) {
        let movie = moviesInfo[i] as! [String: String]

        let searchableItemAttributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeText as String)

        // Set the title.
        searchableItemAttributeSet.title = movie["Title"]!

        // Set the movie image.
        let imagePathParts = movie["Image"]!.componentsSeparatedByString(".")
        searchableItemAttributeSet.thumbnailURL = NSBundle.mainBundle().URLForResource(imagePathParts[0], withExtension: imagePathParts[1])

        // Set the description.
        searchableItemAttributeSet.contentDescription = movie["Description"]!
    }
}
</pre>

<p>注意上面代碼片段中我們是怎麼將電影圖片設置為屬性的。其實有兩種方法來實現：無論是使用圖片的URL地址，或者為圖片提供一個 <em>NSData</em> 物件。對我們來說最簡單的方式就是為每一個電影圖片提供URL地址，因為我們知道這些圖片都存在在應用包(application bundle)中。然而，這個方式需要打破每個圖像文件的實際名和擴展名，所以我們將使用String類中的 <em>componentsSeparatedByString:</em>  方法來分開他們。剩下的都不難去理解。</p>
<p>現在我們該為那些想在Spotlight中被找到的應用數據設置關鍵字了。在想一些特殊的關鍵字之前，你必須明白你的決定是你的應用在Spotlight和用戶被發現的最終關鍵。在範例中我們將設置關鍵字包括電影的類型和它的明星。</p>
<pre lang="swift">func setupSearchableContent() {
    var searchableItems = [CSSearchableItem]()

    for i in 0...(moviesInfo.count - 1) {
        ...

        var keywords = [String]()
        let movieCategories = movie["Category"]!.componentsSeparatedByString(", ")
        for movieCategory in movieCategories {
            keywords.append(movieCategory)
        }

        let stars = movie["Stars"]!.componentsSeparatedByString(", ")
        for star in stars {
            keywords.append(star)
        }

        searchableItemAttributeSet.keywords = keywords
    }
}
</pre>

<p>要記得，電影的分類是被作為一個單個字串表述在 <em>MoviesData.plist</em> 檔中，因此它們會被空格所隔開。所以我們必須將分類的字串值打破然後讓它們分別儲存在 <em>movieCategories</em> 陣列中以方便訪問。然後將每一個值用一個inner迴圈加入 <em>keywords</em> 陣列中。我們對電影中的明星屬性做了一樣合適的步驟，并再一次地打破明星中的字串值，同樣加入keyword陣列。</p>
<p>最重要的一列就是最後一行，我們為每一個電影將我們的關鍵字加入相關屬性中。把這行忘記了意味著在Spotl中對我們的應用搜索不到任何結果。</p>
<p>現在我們已經為Spotlight設置了屬性和關鍵字，是時候去初始化一個可搜索化的項目并將其加入 <em>searchableItems</em> 陣列中了。</p>
<pre lang="swift">func setupSearchableContent() {
    var searchableItems = [CSSearchableItem]()

    for i in 0...(moviesInfo.count - 1) {
        ...

        let searchableItem = CSSearchableItem(uniqueIdentifier: "com.appcoda.SpotIt.\(i)", domainIdentifier: "movies", attributeSet: searchableItemAttributeSet)

        searchableItems.append(searchableItem)
    }
}
</pre>

<p>以上初始化接受了三個參數：</p>
<ul><br><li><em>uniqueIdentifier</em>: 這個參數對在Spotlight中的可搜索化項目要求一個獨一無二的識別標誌。你可以用你喜歡的方式構成這個識別標誌，但注意一個小細節：在這個例子中我們對識別標誌加入當前電影的索引值，我們就會需要到它在隨後展示電影的細節中匹配的索引值。說的更明白點，這是一個好的主意在直向的數據中包含這個識別標誌，以顯示數據的細節。你再來會更明白這個有用的電影索引值。</li><br><li><em>domainIdentifier</em>: 用這個參數將可搜索化項目組成群組。</li><br><li><em>attributeSet</em>: 這個屬性用來設置那些我們剛剛分配值的物件。</li><br></ul>

<p>最後，新的可搜索化項目會被加進 <em>searchableItems</em> 陣列中。</p>
<p>最後我們還有一步要做：運用Core Spotlight API去索引這些項目。這在 <em>for</em> 迴圈以外發生：</p>
<pre lang="swift">func setupSearchableContent() {
    ...

    CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(searchableItems) { (error) -> Void in
        if error != nil {
            print(error?.localizedDescription)
        }
    }
}
</pre>

<p>上述方法已經全部完成，最後我們需要在 <em>viewDidLoad()</em> 中呼叫它：</p>
<pre lang="swift">override func viewDidLoad() {
    ...

    setupSearchableContent()
}
</pre>


<p>我們已經準備好第一次使用Spotlight來搜索電影了。運行這個App，離開它然後在Spotlight中輸入任何我們設置的關鍵字。你會發現搜尋結果會出現在你眼前，通過點擊任何一個結果，應用都會被自動啟動。</p>
<p><img alt="Core Spotlight Demo 2" src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_5_first_search-compressor.gif"></p>
<h2>實現指向性登入</h2>

<p>我們可以通過在Spotlight中搜索到我們的應用中的電影數據，實在是令人印象深刻的事情，但是，還有個地方做的不夠好。到目前為止，在Spotlight觸發項目，應用會進行啟動並且  <em>ViewController</em> 會展示到我們面前，但我們的目標是必須是讓被選擇的電影項目指向detail view controller中，並且看到更多的細節。</p>
<p>主要要做的事情是覆寫UIKit框架中的一個叫做 <em>restoreUserActivityState:</em> 的方法，然後在Spotlight中處理被選擇的項目。我們最終想達到的，是從可搜索化項目中用識別標誌取出<em>moviesInfo</em> 陣列中電影的索引（如果你還記得，我們在先前的部份中創建了動態性的識別標誌），然後我們使用它傳遞適合的電影字典并展示到 <em>MovieDetailsViewController</em> 視圖控制器中。</p>
<p>上述方法的參數是一個 <em>NSUserActivity</em> 物件。這個物件有一個字典屬性叫做 <em>userInfo</em> ，然後這個字典包含了在Spotlight中被選擇的可搜索化項目中的識別標誌。通過這個識別標誌，我們會從 <em>moviesInfo</em> 陣列中取出電影的索引值，然後展示整個細節視圖控制器。就這樣啦。</p>
<p>讓我們看看整個實現的過程：</p>
<pre lang="swift">override func restoreUserActivityState(activity: NSUserActivity) {
    if activity.activityType == CSSearchableItemActionType {
        if let userInfo = activity.userInfo {
            let selectedMovie = userInfo[CSSearchableItemActivityIdentifier] as! String
            selectedMovieIndex = Int(selectedMovie.componentsSeparatedByString(".").last!)
            performSegueWithIdentifier("idSegueShowMovieDetails", sender: self)
        }
    }
}
</pre>

<p>如你所見，我們必選先檢查 <em>activity type</em> 是否符合 <em>CSSearchableItemActionType</em> 的類型。不過其實這在這個範例App中并不重要，但是如果你在你的應用中處理多個 <em>NSUserActivity</em> 物件，這就是你不改忘記去做的東西（比如說， <em>Handoff</em> 特性首先就在iOS 8中使用 <em>NSUserActivity</em> 類）。識別標誌在 <em>userInfo</em> 字典中是一個字串值，一旦我們得到這個值，我們會打破其自身與點符號的組合，然後我們訪問最後一個物件，就是那個在電影集合中被選擇電影的索引值。剩下就簡單多了：我們分配出 <em>selectedMovieIndex</em> 屬性的索引值，然後執行segue。我們先前實現的東西會解決剩下的所有問題。</p>
<p>現在到 <em>AppDelegate.swift</em> 檔中。我們必須在其中去實現一個目前還沒存在的代理方法（delegate function）。當關聯到我們App的項目被觸發時，該方法每次都會被呼叫到，我們的責任就是實現這個被呼叫的方法，而這東西當然是通過user activity來實現的。讓我們看下去：</p>
<pre lang="swift">func application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -> Void) -> Bool {
    let viewController = (window?.rootViewController as! UINavigationController).viewControllers[0] as! ViewController
    viewController.restoreUserActivityState(userActivity)

    return true
}
</pre>

<p>上述代碼片段中，第一件事情就是通過 <em>window</em> 屬性去訪問 <em>ViewController</em> 控制器以優先恢復用戶活動狀態。或者，你可以使用 <em>NSNotificationCenter</em> 然後反過來在 <em>ViewController</em> 類中處理并發出一個自定義通知來代替上述方法，但是上面那個方法更直接一點。</p>
<p>全部搞定！我們的範例App已經完成了，再運行一次然後看看當你觸發Spotlight的項目會發生什麼吧。</p>
<p><img alt="Core Spotlight Final Demo" src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_2_final_sample-compressor.gif"></p>
<h2>總結</h2>

<p>對開發者來說，在iOS 9中新的搜索API是非常有前景的，因為這允許應用能夠更容易被用戶發現和訪問。在這個教程中，我們通過這些方式去建立應用數據的索引，以便在Spotlight被發現，以及一個被選擇的項目是如何通過處理應用中的特殊數據以展示給使用者看。在你的應用中實現這些與衆不同的特性是會提高用戶體驗的，所以，這是你應該嚴肅考慮如何加進你當前和未來項目的重要API。我們再一次的迎來最後，我由衷希望你能在這個教程中找到你需要的幫助。玩的愉快！</p>
<p>如果你需要的話，你可以<a href="https://github.com/appcoda/CoreSpotlightDemo" target="_blank" rel="external">從Github下載整個完整的Xcode項目</a>.</p>
<h2>譯者介紹</h2>

<p>謝岳庭，中文系出身，自學iOS開發，有著异於常人的求知慾。</p>
<p>你可以在Twitter或<a href="http://www.appcoda.com.tw/forum/" target="_blank" rel="external">AppCoda討論區</a>中聯繫我并隨時歡迎你與我交流。</p>
<p>My Twitter: <a href="https://twitter.com/Lanaya_HSIEH" target="_blank" rel="external">@Lanaya_HSIEH</a></p>
<p>My Blog: <a href="/">https://yuejun1991.github.io</a></p>
]]></content:encoded>
      <comments>http://yoursite.com/2016/01/15/How%20to%20use%20Core%20Spotlight%20framework%20in%20iOS%209/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[2015年回顧與總結]]></title>
      <link>http://yoursite.com/2016/01/01/The%20review%20about%202015/</link>
      <guid>http://yoursite.com/2016/01/01/The%20review%20about%202015/</guid>
      <pubDate>Thu, 31 Dec 2015 16:00:00 GMT</pubDate>
      <description>
      <![CDATA[<p>2015年，是我人生中眾多重大變化的其中一年，並且非常關鍵。我希望能對2015年進行足夠的回顧與總結，從而分析出我變化了什麼，強化了什麼，對什麼還有不足。</p>
<p>2015年，最需要感謝的是我的父母，妹妹，我家裡的所有人，以及狗狗Q比。</p>
<p>其次是我在內地的同學，田田，小雨，以及那些不斷支持、鼓勵我的人。</p>
<p>最後是我自己。</p>
<h2 id="1-_u5B78_u7FD2_u4E86_u54EA_u4E9B_u6280_u80FD_u53CA_u990A_u6210_u7FD2_u6163"><a href="#1-_u5B78_u7FD2_u4E86_u54EA_u4E9B_u6280_u80FD_u53CA_u990A_u6210_u7FD2_u6163" class="headerlink" title="1.學習了哪些技能及養成習慣"></a>1.學習了哪些技能及養成習慣</h2><h3 id="u6280_u80FD"><a href="#u6280_u80FD" class="headerlink" title="技能"></a>技能</h3><p>1.iOS程式開發，程式語言主要是Swift。</p>
<p>2.Photoshop的使用，用來簡單修圖和設計海報。</p>
<p>3.MarkDown語法的學習與使用。</p>
<p>4.對UI開發有初步的了解。</p>
<h3 id="u7FD2_u6163"><a href="#u7FD2_u6163" class="headerlink" title="習慣"></a>習慣</h3><p>1.使用過時間管理法，但後來放棄了。現在使用番茄工作法，一個番茄鐘大概在25﹣60分鐘內。</p>
<p>2.早起，基本在6﹣8點起床。</p>
<p>3.開始逐漸養成長時間coding的習慣。</p>
<p>4.初步開始在博客上總結。</p>
<p>5.2015年下半年開始不斷記賬。</p>
<p>6.看英語原文書，主要是程式技術方面。</p>
<p>7.在新浪微博和Twitter上關注iOS開發人員和設計方面。</p>
<p>8.大量減少自己玩遊戲的時間。</p>
<p>9.Coding時習慣聽音樂，並且不習慣外界有干擾。</p>
<p>10.每週對RescueTime的固定回報進行總結分析。</p>
<p>11.用Sleep Better來追蹤自己的睡眠。</p>
<h2 id="2-_u4EA4_u7E54_u7684_u4EBA_u8207_u4E8B"><a href="#2-_u4EA4_u7E54_u7684_u4EBA_u8207_u4E8B" class="headerlink" title="2.交織的人與事"></a>2.交織的人與事</h2><p>2015年4月27日，我正式開始服為期一年的兵役。兵役期間，我在區公所服役，每天和一般公務員一樣上下班。在公所的替代役主要幫忙進行清掃、雜事處理、排列佈置相關活動等，另外有所擅長的人就需要善用所長，比如我會Photoshop方面的應用，那我就幫各個課室做了許多海報，平均下來一個月在2﹣3張。</p>
<p>後來參加了臺中市舉辦的替代役創意爭選活動，代表了我們區公所得到了二等獎（可惜沒有拿第一），做了一個關於兵役相關方面資料的查詢APP。不過我做的并沒有太好，當時程式水平不是很夠，現在回頭來看都非常不合格。</p>
<p>之後民政局讓我做了一個關於役男資料的排版。在最近做了一個關於電話卡正面的封面圖，這兩個都被採納了。</p>
<p>就我看來，台灣學生仍然過於理想，卻安於現狀。與此同時，對待同輩或小一輩人物，不僅不尊重對方人格，且霸陵現象非常嚴重，而他們自己又並未意識到這些問題，依舊嬉笑怒駡，語言粗俗低下。</p>
<p>或許是我自身不善於和人交流，或過於冷漠，專注于自身，而不願加入或制止他們，也和我自身能力的不足有很大的關係。我在兵役期間，也多少遇到了被冷漠或無意識排擠，我也并不想要對目前公所所存在替代役，尋求幫助。而我也依舊保持著該需要我協助就站出來幫忙，該冷眼旁觀而專注于自身發展，便無視外界一切人。</p>
<p>因而2015年我對台灣的學生的大致印象，并不太好。或許是小島國思想封閉以及台灣這十幾年經濟的落寞，台灣學生的思維格局并沒有走出台灣，主要還是以“小確幸”為人生第一要緊事。台灣同樣也是，政治混亂，新聞媒體肆虐，狂舞台灣。無論是食安、黨派、房價、薪資、兩岸等問題，都是台灣人目前還沒辦法解決的各個病痛。台灣雖然醫學世界有名，卻沒辦法合理手術自己身上那顆巨大的腫瘤。</p>
<h2 id="3-_u5927_u81F4_u90FD_u770B_u4E86_u54EA_u4E9B_u66F8"><a href="#3-_u5927_u81F4_u90FD_u770B_u4E86_u54EA_u4E9B_u66F8" class="headerlink" title="3.大致都看了哪些書"></a>3.大致都看了哪些書</h2><p>今年閱讀量大約在25﹣30本書左右，同時閱讀了大量Blog，網站文章，微信公眾號，簡書、知乎、微博、Twitter資源等等。另外還看了很多電影，但是我只看不喜歡寫影評，因而就沒有進行統計。</p>
<p>有的書看了不止一次，像《把時間當做朋友》就至少看了三次，仍然覺得還有很多地方可以學習。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p>2015年，是我人生中眾多重大變化的其中一年，並且非常關鍵。我希望能對2015年進行足夠的回顧與總結，從而分析出我變化了什麼，強化了什麼，對什麼還有不足。</p>
<p>2015年，最需要感謝的是我的父母，妹妹，我家裡的所有人，以及狗狗Q比。</p>
<p>其次是我在內地的同學，田田，小雨，以及那些不斷支持、鼓勵我的人。</p>
<p>最後是我自己。</p>
<h2 id="1-_u5B78_u7FD2_u4E86_u54EA_u4E9B_u6280_u80FD_u53CA_u990A_u6210_u7FD2_u6163"><a href="#1-_u5B78_u7FD2_u4E86_u54EA_u4E9B_u6280_u80FD_u53CA_u990A_u6210_u7FD2_u6163" class="headerlink" title="1.學習了哪些技能及養成習慣"></a>1.學習了哪些技能及養成習慣</h2><h3 id="u6280_u80FD"><a href="#u6280_u80FD" class="headerlink" title="技能"></a>技能</h3><p>1.iOS程式開發，程式語言主要是Swift。</p>
<p>2.Photoshop的使用，用來簡單修圖和設計海報。</p>
<p>3.MarkDown語法的學習與使用。</p>
<p>4.對UI開發有初步的了解。</p>
<h3 id="u7FD2_u6163"><a href="#u7FD2_u6163" class="headerlink" title="習慣"></a>習慣</h3><p>1.使用過時間管理法，但後來放棄了。現在使用番茄工作法，一個番茄鐘大概在25﹣60分鐘內。</p>
<p>2.早起，基本在6﹣8點起床。</p>
<p>3.開始逐漸養成長時間coding的習慣。</p>
<p>4.初步開始在博客上總結。</p>
<p>5.2015年下半年開始不斷記賬。</p>
<p>6.看英語原文書，主要是程式技術方面。</p>
<p>7.在新浪微博和Twitter上關注iOS開發人員和設計方面。</p>
<p>8.大量減少自己玩遊戲的時間。</p>
<p>9.Coding時習慣聽音樂，並且不習慣外界有干擾。</p>
<p>10.每週對RescueTime的固定回報進行總結分析。</p>
<p>11.用Sleep Better來追蹤自己的睡眠。</p>
<h2 id="2-_u4EA4_u7E54_u7684_u4EBA_u8207_u4E8B"><a href="#2-_u4EA4_u7E54_u7684_u4EBA_u8207_u4E8B" class="headerlink" title="2.交織的人與事"></a>2.交織的人與事</h2><p>2015年4月27日，我正式開始服為期一年的兵役。兵役期間，我在區公所服役，每天和一般公務員一樣上下班。在公所的替代役主要幫忙進行清掃、雜事處理、排列佈置相關活動等，另外有所擅長的人就需要善用所長，比如我會Photoshop方面的應用，那我就幫各個課室做了許多海報，平均下來一個月在2﹣3張。</p>
<p>後來參加了臺中市舉辦的替代役創意爭選活動，代表了我們區公所得到了二等獎（可惜沒有拿第一），做了一個關於兵役相關方面資料的查詢APP。不過我做的并沒有太好，當時程式水平不是很夠，現在回頭來看都非常不合格。</p>
<p>之後民政局讓我做了一個關於役男資料的排版。在最近做了一個關於電話卡正面的封面圖，這兩個都被採納了。</p>
<p>就我看來，台灣學生仍然過於理想，卻安於現狀。與此同時，對待同輩或小一輩人物，不僅不尊重對方人格，且霸陵現象非常嚴重，而他們自己又並未意識到這些問題，依舊嬉笑怒駡，語言粗俗低下。</p>
<p>或許是我自身不善於和人交流，或過於冷漠，專注于自身，而不願加入或制止他們，也和我自身能力的不足有很大的關係。我在兵役期間，也多少遇到了被冷漠或無意識排擠，我也并不想要對目前公所所存在替代役，尋求幫助。而我也依舊保持著該需要我協助就站出來幫忙，該冷眼旁觀而專注于自身發展，便無視外界一切人。</p>
<p>因而2015年我對台灣的學生的大致印象，并不太好。或許是小島國思想封閉以及台灣這十幾年經濟的落寞，台灣學生的思維格局并沒有走出台灣，主要還是以“小確幸”為人生第一要緊事。台灣同樣也是，政治混亂，新聞媒體肆虐，狂舞台灣。無論是食安、黨派、房價、薪資、兩岸等問題，都是台灣人目前還沒辦法解決的各個病痛。台灣雖然醫學世界有名，卻沒辦法合理手術自己身上那顆巨大的腫瘤。</p>
<h2 id="3-_u5927_u81F4_u90FD_u770B_u4E86_u54EA_u4E9B_u66F8"><a href="#3-_u5927_u81F4_u90FD_u770B_u4E86_u54EA_u4E9B_u66F8" class="headerlink" title="3.大致都看了哪些書"></a>3.大致都看了哪些書</h2><p>今年閱讀量大約在25﹣30本書左右，同時閱讀了大量Blog，網站文章，微信公眾號，簡書、知乎、微博、Twitter資源等等。另外還看了很多電影，但是我只看不喜歡寫影評，因而就沒有進行統計。</p>
<p>有的書看了不止一次，像《把時間當做朋友》就至少看了三次，仍然覺得還有很多地方可以學習。</p>
<a id="more"></a>
<p>以下書籍不分閱讀順序，10名以後無好壞排序，10名以內的書都值得看3遍以上。</p>
<p>1.《賈伯斯傳》</p>
<p>2.《把時間當做朋友》</p>
<p>3.《iOS_Apprentice》系列，共四本，By Ray WenderLich家</p>
<p>4.《三體》</p>
<p>5.《成為賈伯斯──天才巨星的挫敗與孕成》</p>
<p>6.《演算法統治世界》</p>
<p>7.《養成iOS8APP──程式設計實力的25堂課》</p>
<p>8.《2014﹣2019經濟大懸崖》</p>
<p>9.《微反應》</p>
<p>10.《內向者的優勢》</p>
<p>11.《這個設計好在哪？》</p>
<p>12.《大和魂》</p>
<p>13.《走向世界！哈佛、牛津教你如何鍛鍊思考力》</p>
<p>14.《奇特的一生》</p>
<p>15.《黑客與畫家》</p>
<p>16.《我是一個算命先生2》</p>
<p>17.《深度學習的藝術》</p>
<p>18.《過把癮就死》</p>
<p>19.《拆掉思維里的墻》</p>
<p>20.《高效人士的7種習慣》</p>
<p>21.《IT人的MacTalk》</p>
<p>22.《不看盤投資術》</p>
<p>23.《20幾歲就定位》</p>
<p>24.《學習之道》</p>
<p>25.《我也曾經上班一個禮拜就辭職》</p>
<p>26.《創業時，我們在知乎聊什麼？》</p>
<p>27.《北洋裂變：軍閥與五四》</p>
<h2 id="2016_u5E74_u4E4B_u9032_u4E00_u6B65_u7684_u6253_u7B97"><a href="#2016_u5E74_u4E4B_u9032_u4E00_u6B65_u7684_u6253_u7B97" class="headerlink" title="2016年之進一步的打算"></a>2016年之進一步的打算</h2><p>1.進一步增加每天的Coding時間，同時閱讀GitHub上的源碼。</p>
<p>2.做出2件以上的App。</p>
<p>3.盡力熟練Objective-C。</p>
<p>4.欣賞更多設計作品。</p>
<p>5.爭取閱讀30﹣40本書。</p>
<p>6.每週鍛鍊1﹣2小時，養好身體。</p>
<p>7.提高每天背單詞的數量，提高英語能力。</p>
<p>8.定期寫博客對知識進行總結與分享。</p>
<h2 id="4-_u8CFC_u8CB7_u7684_u90A3_u4E9B_u6771_u897F"><a href="#4-_u8CFC_u8CB7_u7684_u90A3_u4E9B_u6771_u897F" class="headerlink" title="4.購買的那些東西"></a>4.購買的那些東西</h2><p>1.Macbook Pro, 2015年2月13日購買。</p>
<p>2.iPad Air 2, 2015年7月11日購買。</p>
<p>3.克補＋鋅，補充維他命B群等元素。</p>
<p>4.大量的書。</p>
<p>5.GU上的一件黑色大衣，新揹包。</p>
<p>6.巨匠補習班上的技能學習。</p>
<h2 id="5-Mac_u4E0A_u4F7F_u7528_u7684_u8EDF_u4EF6"><a href="#5-Mac_u4E0A_u4F7F_u7528_u7684_u8EDF_u4EF6" class="headerlink" title="5.Mac上使用的軟件"></a>5.Mac上使用的軟件</h2><p>1.Xcode.</p>
<p>2.Photoshop CC 2015</p>
<p>3.Reeder</p>
<p>4.Pomodoro One</p>
<p>5.GitHub Desktop</p>
<p>6.MacDown</p>
<p>7.Twitter</p>
<p>8.AppCleaner</p>
<p>9.Battery Health</p>
<p>10.CleanMyMac 3</p>
<p>11.BetterZip 3.0</p>
<p>12.Hear</p>
<p>13.Infinit</p>
<p>14.Hearthstone</p>
<p>15.Manico</p>
<p>16.RescueTime</p>
<p>17.This War of Mine</p>
<h2 id="6-iPad_u4E0A_u4F7F_u7528_u7684_u8EDF_u4EF6"><a href="#6-iPad_u4E0A_u4F7F_u7528_u7684_u8EDF_u4EF6" class="headerlink" title="6.iPad上使用的軟件"></a>6.iPad上使用的軟件</h2><p>1.即時天氣</p>
<p>2.Gmail</p>
<p>3.WeChat</p>
<p>4.知乎日報、知乎、開發者頭條</p>
<p>5.Sleep Better</p>
<p>6.半糖</p>
<p>7.AppSo</p>
<p>8.Infinit</p>
<p>9.扇貝單詞</p>
<p>10.CodeHub</p>
<p>11.iBooks</p>
<p>12.Monument、Cytus、Implosion</p>
<p>13.Pinterest</p>
<p>14.爐石戰記</p>
<p>15.微博</p>
<p>16.Twitter</p>
<p>17.Kindle</p>
<p>18.網易公開課</p>
]]></content:encoded>
      <comments>http://yoursite.com/2016/01/01/The%20review%20about%202015/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
