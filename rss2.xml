<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Less complaining, More thinking]]></title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[iOS developer. Like coding and reading.]]></description>
    <pubDate>Mon, 25 Jan 2016 11:13:13 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[(譯)iOS Cell Registration & Reusing with Swift Protocol Extensions and Generics]]></title>
      <link>http://yoursite.com/2016/01/17/Tra:%20iOS%20Cell%20Registration%20&%20Reusing%20with%20Swift/</link>
      <guid>http://yoursite.com/2016/01/17/Tra:%20iOS%20Cell%20Registration%20&%20Reusing%20with%20Swift/</guid>
      <pubDate>Sat, 16 Jan 2016 16:00:00 GMT</pubDate>
      <description>
      <![CDATA[<p>如果你使用Storyboards的話，你應該會經常碰到這些情形：為UITableView和UIColloectionView註冊(register)自定義的cell。</p>
<p>UITableView和UICollectionView提供我們一組非常相似的API來註冊自定義的cell:</p>
<pre><code>public func registerClass(cellClass: AnyClass?, forCellWithReuseIdentifier identifier: String)
public func registerNib(nib: UINib?, forCellWithReuseIdentifier identifier: String)
</code></pre><p>一種被廣泛使用來處理註冊和出列的處理方法是為reuse identifier(複用識別)宣告一個常數:</p>
<pre><code>private let reuseIdentifier = &quot;BookCell&quot;

class BookListViewController: UIViewController, UICollectionViewDataSource {

@IBOutlet private weak var collectionView: UICollectionView!

override func viewDidLoad() {
    super.viewDidLoad()

    let nib = UINib(nibName: &quot;BookCell&quot;, bundle: nil)
    self.collectionView.registerNib(nib, forCellWithReuseIdentifier: reuseIdentifier)
}

func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell {
    let cell = collectionView.dequeueReusableCellWithReuseIdentifier(reuseIdentifier, forIndexPath: indexPath)

    if let bookCell = cell as? BookCell {
        // TODO: configure cell
    }

    return cell
    }
}
</code></pre><p>讓我們來嘗試概括一下這段code以及讓它變得更簡單和安全吧。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p>如果你使用Storyboards的話，你應該會經常碰到這些情形：為UITableView和UIColloectionView註冊(register)自定義的cell。</p>
<p>UITableView和UICollectionView提供我們一組非常相似的API來註冊自定義的cell:</p>
<pre><code>public func registerClass(cellClass: AnyClass?, forCellWithReuseIdentifier identifier: String)
public func registerNib(nib: UINib?, forCellWithReuseIdentifier identifier: String)
</code></pre><p>一種被廣泛使用來處理註冊和出列的處理方法是為reuse identifier(複用識別)宣告一個常數:</p>
<pre><code>private let reuseIdentifier = &quot;BookCell&quot;

class BookListViewController: UIViewController, UICollectionViewDataSource {

@IBOutlet private weak var collectionView: UICollectionView!

override func viewDidLoad() {
    super.viewDidLoad()

    let nib = UINib(nibName: &quot;BookCell&quot;, bundle: nil)
    self.collectionView.registerNib(nib, forCellWithReuseIdentifier: reuseIdentifier)
}

func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell {
    let cell = collectionView.dequeueReusableCellWithReuseIdentifier(reuseIdentifier, forIndexPath: indexPath)

    if let bookCell = cell as? BookCell {
        // TODO: configure cell
    }

    return cell
    }
}
</code></pre><p>讓我們來嘗試概括一下這段code以及讓它變得更簡單和安全吧。</p>
<a id="more"></a>
<p>首先，把我們的App中每一個的reuse identifier提取出來。這樣我們只能使用自定義cell類中的名字來作為一個缺省的reuse identifier。</p>
<p>我們可以為Reuseable Views創建一個協議(protocol)並且為UIView的子類提供一個缺省的實現限制。</p>
<pre><code>protocol ReusableView: class {
    static var defaultReuseIdentifier: String { get }
}

extension ReusableView where Self: UIView {
    static var defaultReuseIdentifier: String {
        return NSStringFromClass(self)
    }
}

extension UICollectionViewCell: ReusableView {
}
</code></pre><p>然後讓UICollectionViewCell遵從ReusableView協議，就可以給每一個cell的子類別一個獨一無二的reuse identifier了。</p>
<pre><code>let identifier = BookCell.defaultReuseIdentifier
// identifier = &quot;MyModule.BookCell&quot;
</code></pre><p>接下來我們使用加載Nib的方式來擺脫麻煩的編寫字串(hard-coded string)。</p>
<p>我們繼續為Nib Loadable Views創建一個協議，並且為擴展協議的範圍提供一個缺省值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NibLoadableView</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nibName: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NibLoadableView</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> nibName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NSStringFromClass</span>(<span class="keyword">self</span>).componentsSeparatedByString(<span class="string">"."</span>).last!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BookCell</span>: <span class="title">NibLoadableView</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通過讓BookCell類遵從NIbLoadableView協議，我們現在有一個很安全的方式取得Nib的名字了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let nibName = BookCell<span class="class">.nibName</span></span><br><span class="line"><span class="comment">// nibName = "BookCell"</span></span><br></pre></td></tr></table></figure>
<p>如果你使用一個來自XIB文件的不一樣的名字，而不是Xcode本身提供的，你永遠可以覆寫(override)nibName屬性的缺省值。</p>
<p>有了這兩個協議之後，我們就可以使用Swift的泛型去擴展UICollectionView，達到更簡單註冊和出列cell。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UICollectionView</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">register</span><span class="generics">&lt;T: UICollectionViewCell where T: ReusableView&gt;</span><span class="params">(<span class="number">_</span>: T.<span class="keyword">Type</span>)</span></span> &#123;</span><br><span class="line">        registerClass(<span class="type">T</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="type">T</span>.defaultReuseIdentifier)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">register</span><span class="generics">&lt;T: UICollectionViewCell where T: ReusableView, T: NibLoadableView&gt;</span><span class="params">(<span class="number">_</span>: T.<span class="keyword">Type</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> bundle = <span class="type">NSBundle</span>(forClass: <span class="type">T</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="keyword">let</span> nib = <span class="type">UINib</span>(nibName: <span class="type">T</span>.nibName, bundle: bundle)</span><br><span class="line">        </span><br><span class="line">        registerNib(nib, forCellWithReuseIdentifier: <span class="type">T</span>.defaultReuseIdentifier)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dequeueReusableCell</span><span class="generics">&lt;T: UICollectionViewCell where T: ReusableView&gt;</span><span class="params">(forIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> cell = dequeueReusableCellWithReuseIdentifier(<span class="type">T</span>.defaultReuseIdentifier, forIndexPath: indexPath) <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Could not dequeue cell with identifier: <span class="subst">\(T.defaultReuseIdentifier)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>請注意，我們創建了兩個變化的register方法，一個是實現cell的子類別ReusableView，一個則可以通用於ReuseableView和NibLoadableView。這是非常適合對單獨的view controller用於特定的cell註冊方法(<strong>This nicely decouples the view controller from the specific cell registration method</strong>)。</p>
<p>另外一個好的細節在於dequeueReusableCell方法不需要去使用任何復用的識別碼，而只需要對其回傳的值使用cell的子類別。</p>
<p>現在cell的註冊和出列看起來會更加出色了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListViewController</span>: <span class="title">UIViewController</span>, <span class="title">UICollectionViewDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">@IBOutlet</span> <span class="keyword">private</span> <span class="keyword">weak</span> <span class="keyword">var</span> collectionView: <span class="type">UICollectionView</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.collectionView.register(<span class="type">BookCell</span>.<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">collectionView</span><span class="params">(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UICollectionViewCell</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cell: <span class="type">BookCell</span> = collectionView.dequeueReusableCell(forIndexPath: indexPath)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> configure cell</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u7D50_u5C3E"><a href="#u7D50_u5C3E" class="headerlink" title="結尾"></a>結尾</h2><p>如果你之前學習過Objective-C，去研究Swift的強大的特性比如擴展協定和泛型的特性，以找到更多選擇和更優雅的方式去處理Cocoa類。</p>
<hr>
<p>本文以獲得原作者的翻譯許可。</p>
<h5 id="u5982_u6709_u7FFB_u8B6F_u4E0D_u8DB3_u4E4B_u8655_uFF0C_u8ACB_u591A_u591A_u5305_u542B_u8207_u6307_u6559_u3002"><a href="#u5982_u6709_u7FFB_u8B6F_u4E0D_u8DB3_u4E4B_u8655_uFF0C_u8ACB_u591A_u591A_u5305_u542B_u8207_u6307_u6559_u3002" class="headerlink" title="如有翻譯不足之處，請多多包含與指教。"></a>如有翻譯不足之處，請多多包含與指教。</h5><p><a href="https://medium.com/@gonzalezreal/ios-cell-registration-reusing-with-swift-protocol-extensions-and-generics-c5ac4fb5b75e#.jnkx73nhv" target="_blank" rel="external">原文地址在此</a></p>
]]></content:encoded>
      <comments>http://yoursite.com/2016/01/17/Tra:%20iOS%20Cell%20Registration%20&%20Reusing%20with%20Swift/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[(譯)如何在iOS 9中使用Core Spotlight框架]]></title>
      <link>http://yoursite.com/2016/01/15/%E5%A6%82%E4%BD%95%E5%9C%A8iOS%209%E4%B8%AD%E4%BD%BF%E7%94%A8Core%20Spotlight%E6%A1%86%E6%9E%B6/</link>
      <guid>http://yoursite.com/2016/01/15/%E5%A6%82%E4%BD%95%E5%9C%A8iOS%209%E4%B8%AD%E4%BD%BF%E7%94%A8Core%20Spotlight%E6%A1%86%E6%9E%B6/</guid>
      <pubDate>Thu, 14 Jan 2016 16:00:00 GMT</pubDate>
      <description>
      <![CDATA[<h3 id="u672C_u6587_u70BAHow_to_Use_Core_Spotlight_Framework_in_iOS_9_u7684_u7FFB_u8B6F"><a href="#u672C_u6587_u70BAHow_to_Use_Core_Spotlight_Framework_in_iOS_9_u7684_u7FFB_u8B6F" class="headerlink" title="本文為How to Use Core Spotlight Framework in iOS 9的翻譯"></a>本文為<a href="http://www.appcoda.com/core-spotlight-framework/">How to Use Core Spotlight Framework in iOS 9</a>的翻譯</h3><p>每一次新iOS版本的到來都會帶給全世界所有的開發者們新“東西”并進階已存在的技術。無疑，最新的版本iOS 9，也不會置身于這個傳統之外。開發者們再一次有了新的框架與API以讓他們的App獲得更高水平。其中一個新東西就是 <strong>Core Spotlight</strong> 框架，它靜靜地等待在那邊讓開發者們使用它新的API。</p>
<p>Core Spotlight(CS)框架，是更大型API的集合，以 <em>Search APIs</em> 聞名，這給了開發者們機會去顯著提高他們App被訪問的可發現性，可見性和易用性，這是在以前iOS版本中完全不可能被做到的。Search APIs讓使用者與開發者的聯繫更加緊密，前者可以以更新更快的方式來到達後者的App，後者也可以從前者那獲得更多更迅速的響應。除了Core Spotlight，還有其他新的搜索特性包括在iOS 9中（這裡只是做個介紹）：</p>
<ol><br><li>新的方法和屬性存在與 <em>NSUserActivity</em> 類中（這是用來負責存儲App狀態以為了能讓App在稍後的時間里恢復）。</li><br><li><em>web markup</em> 是用來讓網頁在裝置中被搜索到。</li><br><li><em>universal links</em> 是讓App在網頁鏈接中被直接啟動。</li><br></ol>

<p>我們不會全部處理上述所說的三個方面，而我們將會看到對於Core Spotlight框架的細節。在那之前，我們需要介紹一下這個框架。</p>
<p><img alt="core-spotlight-framework" src="http://www.appcoda.com/wp-content/uploads/2015/12/core-spotlight-framework.jpg"/></p>
<p><a href="https://developer.apple.com/library/ios/documentation/CoreSpotlight/Reference/CoreSpotlight_Framework/">Core Spotlight framework</a> 讓App中的數據 <em>可搜索化</em> ，以及隨後對於系統反饋的搜索結果回傳到App，并在其中打開。這讓使用者可以在第一時間從應用中搜尋到數據（而以前只能搜索到Apple原生的應用的資訊），並且相互作用，這是相當令人印象深刻的變革。按說用戶可以與相關的自定義應用的搜索結果進行互動，而我的意思是，不僅應用程序將因為搜索結果記錄而自動啟動，開發者也同時將用戶吸引到特定視圖控制器(specific view controllers)，這些最合適最恰當的數據就顯示在Spotlight中。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<h3 id="u672C_u6587_u70BAHow_to_Use_Core_Spotlight_Framework_in_iOS_9_u7684_u7FFB_u8B6F"><a href="#u672C_u6587_u70BAHow_to_Use_Core_Spotlight_Framework_in_iOS_9_u7684_u7FFB_u8B6F" class="headerlink" title="本文為How to Use Core Spotlight Framework in iOS 9的翻譯"></a>本文為<a href="http://www.appcoda.com/core-spotlight-framework/" target="_blank" rel="external">How to Use Core Spotlight Framework in iOS 9</a>的翻譯</h3><p>每一次新iOS版本的到來都會帶給全世界所有的開發者們新“東西”并進階已存在的技術。無疑，最新的版本iOS 9，也不會置身于這個傳統之外。開發者們再一次有了新的框架與API以讓他們的App獲得更高水平。其中一個新東西就是 <strong>Core Spotlight</strong> 框架，它靜靜地等待在那邊讓開發者們使用它新的API。</p>
<p>Core Spotlight(CS)框架，是更大型API的集合，以 <em>Search APIs</em> 聞名，這給了開發者們機會去顯著提高他們App被訪問的可發現性，可見性和易用性，這是在以前iOS版本中完全不可能被做到的。Search APIs讓使用者與開發者的聯繫更加緊密，前者可以以更新更快的方式來到達後者的App，後者也可以從前者那獲得更多更迅速的響應。除了Core Spotlight，還有其他新的搜索特性包括在iOS 9中（這裡只是做個介紹）：</p>
<ol><br><li>新的方法和屬性存在與 <em>NSUserActivity</em> 類中（這是用來負責存儲App狀態以為了能讓App在稍後的時間里恢復）。</li><br><li><em>web markup</em> 是用來讓網頁在裝置中被搜索到。</li><br><li><em>universal links</em> 是讓App在網頁鏈接中被直接啟動。</li><br></ol>

<p>我們不會全部處理上述所說的三個方面，而我們將會看到對於Core Spotlight框架的細節。在那之前，我們需要介紹一下這個框架。</p>
<p><img alt="core-spotlight-framework" src="http://www.appcoda.com/wp-content/uploads/2015/12/core-spotlight-framework.jpg"></p>
<p><a href="https://developer.apple.com/library/ios/documentation/CoreSpotlight/Reference/CoreSpotlight_Framework/" target="_blank" rel="external">Core Spotlight framework</a> 讓App中的數據 <em>可搜索化</em> ，以及隨後對於系統反饋的搜索結果回傳到App，并在其中打開。這讓使用者可以在第一時間從應用中搜尋到數據（而以前只能搜索到Apple原生的應用的資訊），並且相互作用，這是相當令人印象深刻的變革。按說用戶可以與相關的自定義應用的搜索結果進行互動，而我的意思是，不僅應用程序將因為搜索結果記錄而自動啟動，開發者也同時將用戶吸引到特定視圖控制器(specific view controllers)，這些最合適最恰當的數據就顯示在Spotlight中。</p>
<a id="more"></a>
<p>其實以開發者的角度來看，結合Core Spotlight框架，並使用其提供的API并不是一個複雜的過程。你即將會發現在本教程中中，需要做到的代碼只有幾行。這其中的核心部份是讓開發者去“告知”iOS關於應用數據的 <em>索引(index)</em> 。</p>
<p>正因本次教程是Core Spotlight框架專屬的，我并不打算在本次介紹中深入其他細節。如果你樂於研究其中是如何實現一些東西的我個人是十分高興的，也請你繼續閱讀下去。我保證你在閱讀到最後會十分滿意這是如何簡單讓你的應用能夠在Spotlight中被識別。</p>
<h2>關於範例App</h2>

<p>我們將一如既往的通過使用一個範例應用來深入了解我們所提到的話題中的細節。在這裡，我們將放置一些數據集合到這個應用中，然後這些數據會被裝置（或模擬器）中的Spotlight所搜尋到。但是首先，我們必須要先來了解一下我們這個應用的一些細節。</p>
<p>這個範例是去展示一些 <em>電影</em> 資訊，比如其摘要，導演，明星陣容，評級等等。所有這些電影資訊會被放置在一個tableview中，當按下其中一列時，某部電影的細節資訊將會被展示在一個新的view controller中。就是這樣，這些東西就可以讓我們可以看到Core Spotlight的API是如何運作的。另外供你參考，我們數據中的這些資源是來自 <em><a href="http://www.imdb.com" target="_blank" rel="external">International Movie Database (IMDB)</a></em> 。我是從這個地方取得樣品數據的。</p>
<p>你可以通過以下動畫來對我們的範例App有一個第一印象。</p>
<p><img alt="Core Spotlight Demo" src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_1_app_working-compressor.gif"></p>
<p>我們在這個教程中有兩個目標。最重要的一個就是讓所有包含在應用中的電影數據可以被Spotlight中搜尋到，然後，使用者會在Spotlight中輸入一些關鍵字來查詢到我們應用中的電影資訊並且展示給他們看。我們的任務與責任就是去決定并設置這些關鍵字。</p>
<p>通過按下一個電影的搜索結果，應用將會被打開，然後我們的第二個目標來了。如果我們沒有進行任何動作，默認的view controller會被加載並且顯示給使用者看，就是那個tableview包含了全部的電影列表的view controller。但這個使用者體驗聽起來並不太妙。一個更好的做法是，我們的應用應該展示那個在Spotlight中被選擇的電影細節，而這也是我們最終要做的。總之，我們不僅會讓我們的電影數據在Spotlight中被搜索到，同時也會當Spotlight中的項目被點擊時在應用中展示相關的細節。以下例子會讓這些更清楚一點：</p>
<p><img alt="Core Spotlight Final Demo" src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_2_final_sample-compressor.gif"></p>
<p>為了不要浪費更多的時間，你可以<a href="https://www.dropbox.com/s/2oge5z8q7u4r11m/SpotItStarter.zip?dl=0" target="_blank" rel="external">在這裡下載一個project</a>。你會在裡面看到這些東西：</p>
<ul><br><li>UI的部份通過所有必要的IBOutlet屬性已經被做好了。</li><br><li>對tableview的一個最小實現。</li><br><li>所有的電影數據都存在于一個.plist文件中。另外，還有一些圖片用來搭配對應的電影（一共5個）。</li><br></ul>

<p>你可能想知道這個列表的電影數據屬性是屬於什麼類別的，你可以通過以下一個屏幕截圖來了解到這些信息：</p>
<p><img alt="t46_3_movie_plist_sample" src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_3_movie_plist_sample.png"></p>
<p>我們將會在看到Core Spotlight API的更多細節之前，先做兩個不同的任務：</p>
<ol><br><li>我們先要載入和放置電影數據到tableview中。</li><br><li>我們將展示一個被選擇的電影資訊到detail view controller中。</li><br></ol>

<p>我并沒有在起始項目中實現上述任務，即使這會讓我們更快進入這方面的話題，原因是：我非常自信通過了解這個範例應用和樣品的數據，會讓你有更多的對於具體數據是如何被Spotlight所搜索到有更多的認識。不用擔心，前期工作不多，可以做的很快。</p>
<h2>加載和展示樣品的數據</h2>

<p>如果你已經下載好了起始項目并看了關於電影數據的plist檔，我們就開始吧。在 <em>MoviesData.plist</em> 文件中你會發現一共有5個入口，每一個樣品電影都是隨機在IMDB網站上取得的。我們的第一個任務是從.plist檔中加載數據到一個array里，然後把array放進tableview</p>
<p>直接進入代碼里，打開 <em>ViewController.swift</em> 檔，這個我們主要運用到的文件，然後在class裡面的最上方宣告以下屬性：</p>
<pre lang="swift">var moviesInfo: NSMutableArray!
</pre>

<p>所有電影都會被加載進這個array中，每一個電影都會以存在于屬性列表文件中的屬性來代表成一個dictionary，裡面包含了keys和values.</p>
<p>讓我們先寫一個小型自定義方法，在該方法里，將會進行數據加載。我們首先確保這個屬性列表文件是存在的，如此之後，我們才在這個array中初始化文件中的內容：</p>
<pre lang="swift">func loadMoviesInfo() {
    if let path = NSBundle.mainBundle().pathForResource("MoviesData", ofType: "plist") {
        moviesInfo = NSMutableArray(contentsOfFile: path)
    }
}
</pre>

<p>接下來，我們必須在 <em>viewDidLoad()</em> 方法中呼叫它。你必須確保這個呼叫必須在 <em>configureTableView()</em> 方法發生之前：</p>
<pre lang="swift">override func viewDidLoad() {
    super.viewDidLoad()

    // Load the movies data from the file.
    loadMoviesInfo()

    configureTableView()
    navigationItem.title = "Movies"
}
</pre>

<p>注意以上創建的自定義方法當然可以寫在 <em>viewDidLoad()</em> 中，但是為了有整潔的代碼風格，我們這種方式可以讓代碼變得更輕更好。</p>
<p>你應該知道電影數據要在應用啟動前被加載，然後我們才能夠繼續將當前的tableview實例化去展示我們的電影數據。這裡不會再做其他事情了。我們將會依據電影來決定列的數量，然後將屬性數據展示在tableview的cell上。</p>
<p>很明顯的，列的數量應該是和電影的數量相等的。但是，我們應該不應該忘記首先需要去保證確實存在可展示的電影，不然整個應用將會瞬間崩潰，因為在這種情況下文件內容不會被加載到array中。</p>
<pre lang="swift">func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
    if moviesInfo != nil {
        return moviesInfo.count
    }

    return 0
}
</pre>

<p>最後，讓我們將這些電影數據展示出來。在這個範例應用的起始項目上，你可以找到一個屬於 <em>UITableViewCell</em> 類的子類叫做 <em>MovieSummaryCell</em> ，以及對應的 <em>.xib</em> 檔去表示單個電影cell：</p>
<p><img src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_4_custom_cell_ib.png" alt="t46_4_custom_cell_ib" class="aligncenter size-full wp-image-6868"></p>
<p>每一個cell都會展示出圖片，標題，描述的部份以及每一部電影的評價。所有的UI控制器都已經和IBOutlet屬性連接，你可以在 <em>MovieSummaryCell.swift</em> 檔中找到他們。</p>
<pre lang="swift">@IBOutlet weak var imgMovieImage: UIImageView!

@IBOutlet weak var lblTitle: UILabel!

@IBOutlet weak var lblDescription: UILabel!

@IBOutlet weak var lblRating: UILabel!
</pre>

<p>上述名稱都暗示了每個屬性的目的。既然我們已經看到了他們，那我們就開始讓他們與我們電影的細節關聯上吧。回到 <em>ViewController.swift</em> 中，通過接下來的程式碼來更新tableview中的方法：</p>
<pre lang="swift">func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -> UITableViewCell {
    let cell = tableView.dequeueReusableCellWithIdentifier("idCellMovieSummary", forIndexPath: indexPath) as! MovieSummaryCell

    let currentMovieInfo = moviesInfo[indexPath.row] as! [String: String]

    cell.lblTitle.text = currentMovieInfo["Title"]!
    cell.lblDescription.text = currentMovieInfo["Description"]!
    cell.lblRating.text = currentMovieInfo["Rating"]!
    cell.imgMovieImage.image = UIImage(named:     currentMovieInfo["Image"]!)

    return cell

}
</pre>

<p>對於 <em>currentMovieInfo</em> 字典的使用並非是必須的，然而這讓整個程式碼看起來清晰易讀。</p>
<p>你可以先執行一次這個應用，你會看到電影的細節都被tableview所監聽到。到目前為止我們都做了大家很熟悉的東西，現在讓我們直接進入第二預備步驟：將電影的細節部份展示出來。</p>
<h2>展示數據細節</h2>

<p>我們將在 <em>MovieDetailsViewController</em> 類中展示每一個從屬於 <em>ViewController</em> 類的tableview中被選擇的電影的細節。各自的場景都已經在Interface Builder中存在了，所以我們將做兩件事情：從 <em>ViewController</em> 傳遞合適的電影字典到這個類中，然後放置那些字典裡面的值到合適的UI控制器上，就是那些你能看到的所有的已經被宣告和連接的IBOutlet屬性。</p>
<p>為了與字典進行對話，讓我們接下來在 <em>MovieDetailsViewController</em> 類內面的最上方做一個宣告：</p>
<pre lang="swift">var movieInfo: [String: String]!
</pre>

<p>讓我們馬上回到 <em>ViewController</em> 檔中，去看看我們接下來當電影列被觸發時應該做什麼。當這件事情發生時，我們想要知道是哪一個列被按下。我們從 <em>moviesInfo</em> 陣列中挑選合適的字典傳遞到下一個view controller上，同時，一個叫做 <em>idSegueShowMovieDetails</em> 的segue將會被執行。取得該列的索引並不麻煩，我們只需要一個自定義的屬性來存放它就好了。因此我們在 <em>ViewController</em> 類里還需要宣告這個：</p>
<pre lang="swift">var selectedMovieIndex: Int!
</pre>

<p>然後，我們需要去處理tableview中的列被選擇時需要執行的方法：</p>
<pre lang="swift">func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
    selectedMovieIndex = indexPath.row
    performSegueWithIdentifier("idSegueShowMovieDetails", sender: self)
}
</pre>

<p>我們一共做了兩件簡單的事情：我們先在我們自己的屬性中，儲存了被按下的列的索引，然後執行segue去讓我們的電影細節被展示出來。但這還不夠，我們還沒從 <em>moviesInfo</em> 陣列中挑選合適的電影字典，我們也沒有傳遞任何東西到 <em>MovieDetailsViewController</em> 中。我們應該怎麼做？答案是去覆寫 <em>prepareForSegue:sender:</em> 方法然後做我剛剛說的事情，我們看看是怎麼做到的：</p>
<pre lang="swift">override func prepareForSegue(segue: UIStoryboardSegue, sender: AnyObject?) {
    if let identifier = segue.identifier {
        if identifier == "idSegueShowMovieDetails" {
            let movieDetailsViewController = segue.destinationViewController as! MovieDetailsViewController
            movieDetailsViewController.movieInfo = moviesInfo[selectedMovieIndex] as! [String : String]
        }
    }
}
</pre>

<p>這很簡單，我們通過segue的屬性  <em>destinationViewController</em> 取得到了 <em>MovieDetailsViewController</em> 的實例變量，然後我們將合適的電影字典分配到了剛剛在這部份開始宣告的屬性 <em>movieInfo</em> 上。</p>
<p>現在，再一次打開 <em>MovieDetailsViewController.swift</em> 檔，我們只要宣告一個自定的方法。在這方面里，我們將從 <em>movieInfo</em> 字典中分配合適的值到合適的UI控制器中，然後這一部份就基本告一段落了。這下面的代碼實現并不複雜，所以我不做其他解釋了：</p>
<pre lang="swift">func populateMovieInfo() {
    lblTitle.text = movieInfo["Title"]!
    lblCategory.text = movieInfo["Category"]!
    lblDescription.text = movieInfo["Description"]!
    lblDirector.text = movieInfo["Director"]!
    lblStars.text = movieInfo["Stars"]!
    lblRating.text = movieInfo["Rating"]!
    imgMovieImage.image = UIImage(named: movieInfo["Image"]!)
}
</pre>

<p>隨後，在 <em>viewWillAppear:</em> 方法中呼叫上述方法就好啦：</p>
<pre lang="swift">override func viewWillAppear(animated: Bool) {
    ...

    if movieInfo != nil {
            populateMovieInfo()
    }
}
</pre>

<p>這部份又告一段落啦，你可以再試一次這個App，然後去看看你從tableview中選擇的每一個電影細節吧。</p>
<h2>對於Spotlight的索引數據</h2>

<p>通過使用iOS 9中的Core Spotlight框架，任何一個應用的數據都可以通過Spotlight被搜索到。關鍵就是從Core Spotlight的API中特別詢問我們數據的 <em>索引</em> 是什麼，這樣數據就可以給使用者正確地尋找到了。但是我們的應用中，都還沒有讓我們的數據去使用CS API。我們需要去為我們的數據以特別的方式準備和提供那些API。</p>
<p>說的更清楚一點，那些我們想要通過Spotlight被搜尋到的數據都必須在 <em>CSSearchableItem</em> 物件中被描述出來，然後將它們以陣列的方式組合并用CS API做出索引。 單一 <em>CSSearchableItem</em> 物件包含了一些屬性讓iOS以更快更乾淨的方式來找到每一個能被搜尋的項目，比如說什麼數據應該在搜索的時候被展示出來（例如電影的名字，它的圖片和描述），還有是什麼關鍵字導致我們應用中的數據被Spotlight搜尋到之類。所有這些屬性都包含在一個叫做 <em>CSSearchableItemAttributeSet</em> 的物件中，它可以提供許多屬性讓我們去分配我們需要的值。如果你需要，我給你<a href="https://developer.apple.com/library/prerelease/ios/documentation/CoreSpotlight/Reference/CSSearchableItemAttributeSet_Class/index.html" target="_blank" rel="external">官方文檔鏈接</a>，這樣你就可以看到所有被支持的屬性啦。</p>
<p>為Spotlight中的數據設置索引是最後才要做的事情。通常來說按照以下流程：</p>
<ol><br><li>為每一段數據設置它們獨有的屬性，比如一個電影。（ <em>CSSearchableItemAttributeSet</em> ）</li><br><li>用之前的屬性為每一段數據初始化一個可被搜索的項目。（ <em>CSSearchableItem</em> ）</li><br><li>把這些可被搜索的項目都放入一個陣列中。</li><br><li>為陣列中的每一個項目設置一個索引。</li><br></ol>

<p>我們將一步一步來。為了完成我們的目的，我們將在 <em>ViewController.swift</em> 檔中創立一個叫做 <em>setupSearchableContent()</em> 的自定義方法。在我們這部份最後的實例變量中你會發現讓你的數據變得可搜索化並不難。但是我們不會直接把整個方法一次實現。我會將代碼進行拆解，讓你可以足夠簡單地消化下去。這一點也不多。</p>
<p>在我們實現我們的方法之前，我們必須先import兩個框架：</p>
<pre lang="swift">import CoreSpotlight
import MobileCoreServices
</pre>

<p>我們可以開始給我們的新方法下定義了。在方法開始宣告一個用來收集可搜索化項目的集合：</p>
<pre lang="swift">func setupSearchableContent() {
    var searchableItems = [CSSearchableItem]()
}
</pre>

<p>在迴圈中我們開始分配每一個電影：</p>
<pre lang="swift">func setupSearchableContent() {
    var searchableItems = [CSSearchableItem]()

    for i in 0...(moviesInfo.count - 1) {
        let movie = moviesInfo[i] as! [String: String]
    }
}
</pre>

<p>對每個電影，我們都會創建一個 <em>CSSearchableItemAttributeSet</em> 物件，然後設置那些當在Spotlight被搜索時，我們想展示出來的搜索結果的屬性。在我們的範例中，我們會明確出電影的標題，描述和圖片來作為我們想給使用者看到的數據片段。</p>
<pre lang="swift">func setupSearchableContent() {
    var searchableItems = [CSSearchableItem]()

    for i in 0...(moviesInfo.count - 1) {
        let movie = moviesInfo[i] as! [String: String]

        let searchableItemAttributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeText as String)

        // Set the title.
        searchableItemAttributeSet.title = movie["Title"]!

        // Set the movie image.
        let imagePathParts = movie["Image"]!.componentsSeparatedByString(".")
        searchableItemAttributeSet.thumbnailURL = NSBundle.mainBundle().URLForResource(imagePathParts[0], withExtension: imagePathParts[1])

        // Set the description.
        searchableItemAttributeSet.contentDescription = movie["Description"]!
    }
}
</pre>

<p>注意上面代碼片段中我們是怎麼將電影圖片設置為屬性的。其實有兩種方法來實現：無論是使用圖片的URL地址，或者為圖片提供一個 <em>NSData</em> 物件。對我們來說最簡單的方式就是為每一個電影圖片提供URL地址，因為我們知道這些圖片都存在在應用包(application bundle)中。然而，這個方式需要打破每個圖像文件的實際名和擴展名，所以我們將使用String類中的 <em>componentsSeparatedByString:</em>  方法來分開他們。剩下的都不難去理解。</p>
<p>現在我們該為那些想在Spotlight中被找到的應用數據設置關鍵字了。在想一些特殊的關鍵字之前，你必須明白你的決定是你的應用在Spotlight和用戶被發現的最終關鍵。在範例中我們將設置關鍵字包括電影的類型和它的明星。</p>
<pre lang="swift">func setupSearchableContent() {
    var searchableItems = [CSSearchableItem]()

    for i in 0...(moviesInfo.count - 1) {
        ...

        var keywords = [String]()
        let movieCategories = movie["Category"]!.componentsSeparatedByString(", ")
        for movieCategory in movieCategories {
            keywords.append(movieCategory)
        }

        let stars = movie["Stars"]!.componentsSeparatedByString(", ")
        for star in stars {
            keywords.append(star)
        }

        searchableItemAttributeSet.keywords = keywords
    }
}
</pre>

<p>要記得，電影的分類是被作為一個單個字串表述在 <em>MoviesData.plist</em> 檔中，因此它們會被空格所隔開。所以我們必須將分類的字串值打破然後讓它們分別儲存在 <em>movieCategories</em> 陣列中以方便訪問。然後將每一個值用一個inner迴圈加入 <em>keywords</em> 陣列中。我們對電影中的明星屬性做了一樣合適的步驟，并再一次地打破明星中的字串值，同樣加入keyword陣列。</p>
<p>最重要的一列就是最後一行，我們為每一個電影將我們的關鍵字加入相關屬性中。把這行忘記了意味著在Spotl中對我們的應用搜索不到任何結果。</p>
<p>現在我們已經為Spotlight設置了屬性和關鍵字，是時候去初始化一個可搜索化的項目并將其加入 <em>searchableItems</em> 陣列中了。</p>
<pre lang="swift">func setupSearchableContent() {
    var searchableItems = [CSSearchableItem]()

    for i in 0...(moviesInfo.count - 1) {
        ...

        let searchableItem = CSSearchableItem(uniqueIdentifier: "com.appcoda.SpotIt.\(i)", domainIdentifier: "movies", attributeSet: searchableItemAttributeSet)

        searchableItems.append(searchableItem)
    }
}
</pre>

<p>以上初始化接受了三個參數：</p>
<ul><br><li><em>uniqueIdentifier</em>: 這個參數對在Spotlight中的可搜索化項目要求一個獨一無二的識別標誌。你可以用你喜歡的方式構成這個識別標誌，但注意一個小細節：在這個例子中我們對識別標誌加入當前電影的索引值，我們就會需要到它在隨後展示電影的細節中匹配的索引值。說的更明白點，這是一個好的主意在直向的數據中包含這個識別標誌，以顯示數據的細節。你再來會更明白這個有用的電影索引值。</li><br><li><em>domainIdentifier</em>: 用這個參數將可搜索化項目組成群組。</li><br><li><em>attributeSet</em>: 這個屬性用來設置那些我們剛剛分配值的物件。</li><br></ul>

<p>最後，新的可搜索化項目會被加進 <em>searchableItems</em> 陣列中。</p>
<p>最後我們還有一步要做：運用Core Spotlight API去索引這些項目。這在 <em>for</em> 迴圈以外發生：</p>
<pre lang="swift">func setupSearchableContent() {
    ...

    CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(searchableItems) { (error) -> Void in
        if error != nil {
            print(error?.localizedDescription)
        }
    }
}
</pre>

<p>上述方法已經全部完成，最後我們需要在 <em>viewDidLoad()</em> 中呼叫它：</p>
<pre lang="swift">override func viewDidLoad() {
    ...

    setupSearchableContent()
}
</pre>


<p>我們已經準備好第一次使用Spotlight來搜索電影了。運行這個App，離開它然後在Spotlight中輸入任何我們設置的關鍵字。你會發現搜尋結果會出現在你眼前，通過點擊任何一個結果，應用都會被自動啟動。</p>
<p><img alt="Core Spotlight Demo 2" src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_5_first_search-compressor.gif"></p>
<h2>實現指向性登入</h2>

<p>我們可以通過在Spotlight中搜索到我們的應用中的電影數據，實在是令人印象深刻的事情，但是，還有個地方做的不夠好。到目前為止，在Spotlight觸發項目，應用會進行啟動並且  <em>ViewController</em> 會展示到我們面前，但我們的目標是必須是讓被選擇的電影項目指向detail view controller中，並且看到更多的細節。</p>
<p>主要要做的事情是覆寫UIKit框架中的一個叫做 <em>restoreUserActivityState:</em> 的方法，然後在Spotlight中處理被選擇的項目。我們最終想達到的，是從可搜索化項目中用識別標誌取出<em>moviesInfo</em> 陣列中電影的索引（如果你還記得，我們在先前的部份中創建了動態性的識別標誌），然後我們使用它傳遞適合的電影字典并展示到 <em>MovieDetailsViewController</em> 視圖控制器中。</p>
<p>上述方法的參數是一個 <em>NSUserActivity</em> 物件。這個物件有一個字典屬性叫做 <em>userInfo</em> ，然後這個字典包含了在Spotlight中被選擇的可搜索化項目中的識別標誌。通過這個識別標誌，我們會從 <em>moviesInfo</em> 陣列中取出電影的索引值，然後展示整個細節視圖控制器。就這樣啦。</p>
<p>讓我們看看整個實現的過程：</p>
<pre lang="swift">override func restoreUserActivityState(activity: NSUserActivity) {
    if activity.activityType == CSSearchableItemActionType {
        if let userInfo = activity.userInfo {
            let selectedMovie = userInfo[CSSearchableItemActivityIdentifier] as! String
            selectedMovieIndex = Int(selectedMovie.componentsSeparatedByString(".").last!)
            performSegueWithIdentifier("idSegueShowMovieDetails", sender: self)
        }
    }
}
</pre>

<p>如你所見，我們必選先檢查 <em>activity type</em> 是否符合 <em>CSSearchableItemActionType</em> 的類型。不過其實這在這個範例App中并不重要，但是如果你在你的應用中處理多個 <em>NSUserActivity</em> 物件，這就是你不改忘記去做的東西（比如說， <em>Handoff</em> 特性首先就在iOS 8中使用 <em>NSUserActivity</em> 類）。識別標誌在 <em>userInfo</em> 字典中是一個字串值，一旦我們得到這個值，我們會打破其自身與點符號的組合，然後我們訪問最後一個物件，就是那個在電影集合中被選擇電影的索引值。剩下就簡單多了：我們分配出 <em>selectedMovieIndex</em> 屬性的索引值，然後執行segue。我們先前實現的東西會解決剩下的所有問題。</p>
<p>現在到 <em>AppDelegate.swift</em> 檔中。我們必須在其中去實現一個目前還沒存在的代理方法（delegate function）。當關聯到我們App的項目被觸發時，該方法每次都會被呼叫到，我們的責任就是實現這個被呼叫的方法，而這東西當然是通過user activity來實現的。讓我們看下去：</p>
<pre lang="swift">func application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -> Void) -> Bool {
    let viewController = (window?.rootViewController as! UINavigationController).viewControllers[0] as! ViewController
    viewController.restoreUserActivityState(userActivity)

    return true
}
</pre>

<p>上述代碼片段中，第一件事情就是通過 <em>window</em> 屬性去訪問 <em>ViewController</em> 控制器以優先恢復用戶活動狀態。或者，你可以使用 <em>NSNotificationCenter</em> 然後反過來在 <em>ViewController</em> 類中處理并發出一個自定義通知來代替上述方法，但是上面那個方法更直接一點。</p>
<p>全部搞定！我們的範例App已經完成了，再運行一次然後看看當你觸發Spotlight的項目會發生什麼吧。</p>
<p><img alt="Core Spotlight Final Demo" src="http://www.appcoda.com/wp-content/uploads/2015/12/t46_2_final_sample-compressor.gif"></p>
<h2>總結</h2>

<p>對開發者來說，在iOS 9中新的搜索API是非常有前景的，因為這允許應用能夠更容易被用戶發現和訪問。在這個教程中，我們通過這些方式去建立應用數據的索引，以便在Spotlight被發現，以及一個被選擇的項目是如何通過處理應用中的特殊數據以展示給使用者看。在你的應用中實現這些與衆不同的特性是會提高用戶體驗的，所以，這是你應該嚴肅考慮如何加進你當前和未來項目的重要API。我們再一次的迎來最後，我由衷希望你能在這個教程中找到你需要的幫助。玩的愉快！</p>
<p>如果你需要的話，你可以<a href="https://github.com/appcoda/CoreSpotlightDemo" target="_blank" rel="external">從Github下載整個完整的Xcode項目</a>.</p>
<h2>譯者介紹</h2>

<p>謝岳庭，中文系出身，自學iOS開發，有著异於常人的求知慾。</p>
<p>你可以在Twitter或<a href="http://www.appcoda.com.tw/forum/" target="_blank" rel="external">AppCoda討論區</a>中聯繫我并隨時歡迎你與我交流。</p>
<p>My Twitter: <a href="https://twitter.com/Lanaya_HSIEH" target="_blank" rel="external">@Lanaya_HSIEH</a></p>
<p>My Blog: <a href="/">https://yuejun1991.github.io</a></p>
]]></content:encoded>
      <comments>http://yoursite.com/2016/01/15/%E5%A6%82%E4%BD%95%E5%9C%A8iOS%209%E4%B8%AD%E4%BD%BF%E7%94%A8Core%20Spotlight%E6%A1%86%E6%9E%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[2015年回顧與總結]]></title>
      <link>http://yoursite.com/2016/01/01/2015%E5%B9%B4%E5%9B%9E%E9%A1%A7%E8%88%87%E7%B8%BD%E7%B5%90/</link>
      <guid>http://yoursite.com/2016/01/01/2015%E5%B9%B4%E5%9B%9E%E9%A1%A7%E8%88%87%E7%B8%BD%E7%B5%90/</guid>
      <pubDate>Thu, 31 Dec 2015 16:00:00 GMT</pubDate>
      <description>
      <![CDATA[<p>2015年，是我人生中眾多重大變化的其中一年，並且非常關鍵。我希望能對2015年進行足夠的回顧與總結，從而分析出我變化了什麼，強化了什麼，對什麼還有不足。</p>
<p>2015年，最需要感謝的是我的父母，妹妹，我家裡的所有人，以及狗狗Q比。</p>
<p>其次是我在內地的同學，田田，小雨，以及那些不斷支持、鼓勵我的人。</p>
<p>最後是我自己。</p>
<h2 id="1-_u5B78_u7FD2_u4E86_u54EA_u4E9B_u6280_u80FD_u53CA_u990A_u6210_u7FD2_u6163"><a href="#1-_u5B78_u7FD2_u4E86_u54EA_u4E9B_u6280_u80FD_u53CA_u990A_u6210_u7FD2_u6163" class="headerlink" title="1.學習了哪些技能及養成習慣"></a>1.學習了哪些技能及養成習慣</h2><h3 id="u6280_u80FD"><a href="#u6280_u80FD" class="headerlink" title="技能"></a>技能</h3><p>1.iOS程式開發，程式語言主要是Swift。</p>
<p>2.Photoshop的使用，用來簡單修圖和設計海報。</p>
<p>3.MarkDown語法的學習與使用。</p>
<p>4.對UI開發有初步的了解。</p>
<h3 id="u7FD2_u6163"><a href="#u7FD2_u6163" class="headerlink" title="習慣"></a>習慣</h3><p>1.使用過時間管理法，但後來放棄了。現在使用番茄工作法，一個番茄鐘大概在25﹣60分鐘內。</p>
<p>2.早起，基本在6﹣8點起床。</p>
<p>3.開始逐漸養成長時間coding的習慣。</p>
<p>4.初步開始在博客上總結。</p>
<p>5.2015年下半年開始不斷記賬。</p>
<p>6.看英語原文書，主要是程式技術方面。</p>
<p>7.在新浪微博和Twitter上關注iOS開發人員和設計方面。</p>
<p>8.大量減少自己玩遊戲的時間。</p>
<p>9.Coding時習慣聽音樂，並且不習慣外界有干擾。</p>
<p>10.每週對RescueTime的固定回報進行總結分析。</p>
<p>11.用Sleep Better來追蹤自己的睡眠。</p>
<h2 id="2-_u4EA4_u7E54_u7684_u4EBA_u8207_u4E8B"><a href="#2-_u4EA4_u7E54_u7684_u4EBA_u8207_u4E8B" class="headerlink" title="2.交織的人與事"></a>2.交織的人與事</h2><p>2015年4月27日，我正式開始服為期一年的兵役。兵役期間，我在區公所服役，每天和一般公務員一樣上下班。在公所的替代役主要幫忙進行清掃、雜事處理、排列佈置相關活動等，另外有所擅長的人就需要善用所長，比如我會Photoshop方面的應用，那我就幫各個課室做了許多海報，平均下來一個月在2﹣3張。</p>
<p>後來參加了臺中市舉辦的替代役創意爭選活動，代表了我們區公所得到了二等獎（可惜沒有拿第一），做了一個關於兵役相關方面資料的查詢APP。不過我做的并沒有太好，當時程式水平不是很夠，現在回頭來看都非常不合格。</p>
<p>之後民政局讓我做了一個關於役男資料的排版。在最近做了一個關於電話卡正面的封面圖，這兩個都被採納了。</p>
<p>就我看來，台灣學生仍然過於理想，卻安於現狀。與此同時，對待同輩或小一輩人物，不僅不尊重對方人格，且霸陵現象非常嚴重，而他們自己又並未意識到這些問題，依舊嬉笑怒駡，語言粗俗低下。</p>
<p>或許是我自身不善於和人交流，或過於冷漠，專注于自身，而不願加入或制止他們，也和我自身能力的不足有很大的關係。我在兵役期間，也多少遇到了被冷漠或無意識排擠，我也并不想要對目前公所所存在替代役，尋求幫助。而我也依舊保持著該需要我協助就站出來幫忙，該冷眼旁觀而專注于自身發展，便無視外界一切人。</p>
<p>因而2015年我對台灣的學生的大致印象，并不太好。或許是小島國思想封閉以及台灣這十幾年經濟的落寞，台灣學生的思維格局并沒有走出台灣，主要還是以“小確幸”為人生第一要緊事。台灣同樣也是，政治混亂，新聞媒體肆虐，狂舞台灣。無論是食安、黨派、房價、薪資、兩岸等問題，都是台灣人目前還沒辦法解決的各個病痛。台灣雖然醫學世界有名，卻沒辦法合理手術自己身上那顆巨大的腫瘤。</p>
<h2 id="3-_u5927_u81F4_u90FD_u770B_u4E86_u54EA_u4E9B_u66F8"><a href="#3-_u5927_u81F4_u90FD_u770B_u4E86_u54EA_u4E9B_u66F8" class="headerlink" title="3.大致都看了哪些書"></a>3.大致都看了哪些書</h2><p>今年閱讀量大約在25﹣30本書左右，同時閱讀了大量Blog，網站文章，微信公眾號，簡書、知乎、微博、Twitter資源等等。另外還看了很多電影，但是我只看不喜歡寫影評，因而就沒有進行統計。</p>
<p>有的書看了不止一次，像《把時間當做朋友》就至少看了三次，仍然覺得還有很多地方可以學習。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p>2015年，是我人生中眾多重大變化的其中一年，並且非常關鍵。我希望能對2015年進行足夠的回顧與總結，從而分析出我變化了什麼，強化了什麼，對什麼還有不足。</p>
<p>2015年，最需要感謝的是我的父母，妹妹，我家裡的所有人，以及狗狗Q比。</p>
<p>其次是我在內地的同學，田田，小雨，以及那些不斷支持、鼓勵我的人。</p>
<p>最後是我自己。</p>
<h2 id="1-_u5B78_u7FD2_u4E86_u54EA_u4E9B_u6280_u80FD_u53CA_u990A_u6210_u7FD2_u6163"><a href="#1-_u5B78_u7FD2_u4E86_u54EA_u4E9B_u6280_u80FD_u53CA_u990A_u6210_u7FD2_u6163" class="headerlink" title="1.學習了哪些技能及養成習慣"></a>1.學習了哪些技能及養成習慣</h2><h3 id="u6280_u80FD"><a href="#u6280_u80FD" class="headerlink" title="技能"></a>技能</h3><p>1.iOS程式開發，程式語言主要是Swift。</p>
<p>2.Photoshop的使用，用來簡單修圖和設計海報。</p>
<p>3.MarkDown語法的學習與使用。</p>
<p>4.對UI開發有初步的了解。</p>
<h3 id="u7FD2_u6163"><a href="#u7FD2_u6163" class="headerlink" title="習慣"></a>習慣</h3><p>1.使用過時間管理法，但後來放棄了。現在使用番茄工作法，一個番茄鐘大概在25﹣60分鐘內。</p>
<p>2.早起，基本在6﹣8點起床。</p>
<p>3.開始逐漸養成長時間coding的習慣。</p>
<p>4.初步開始在博客上總結。</p>
<p>5.2015年下半年開始不斷記賬。</p>
<p>6.看英語原文書，主要是程式技術方面。</p>
<p>7.在新浪微博和Twitter上關注iOS開發人員和設計方面。</p>
<p>8.大量減少自己玩遊戲的時間。</p>
<p>9.Coding時習慣聽音樂，並且不習慣外界有干擾。</p>
<p>10.每週對RescueTime的固定回報進行總結分析。</p>
<p>11.用Sleep Better來追蹤自己的睡眠。</p>
<h2 id="2-_u4EA4_u7E54_u7684_u4EBA_u8207_u4E8B"><a href="#2-_u4EA4_u7E54_u7684_u4EBA_u8207_u4E8B" class="headerlink" title="2.交織的人與事"></a>2.交織的人與事</h2><p>2015年4月27日，我正式開始服為期一年的兵役。兵役期間，我在區公所服役，每天和一般公務員一樣上下班。在公所的替代役主要幫忙進行清掃、雜事處理、排列佈置相關活動等，另外有所擅長的人就需要善用所長，比如我會Photoshop方面的應用，那我就幫各個課室做了許多海報，平均下來一個月在2﹣3張。</p>
<p>後來參加了臺中市舉辦的替代役創意爭選活動，代表了我們區公所得到了二等獎（可惜沒有拿第一），做了一個關於兵役相關方面資料的查詢APP。不過我做的并沒有太好，當時程式水平不是很夠，現在回頭來看都非常不合格。</p>
<p>之後民政局讓我做了一個關於役男資料的排版。在最近做了一個關於電話卡正面的封面圖，這兩個都被採納了。</p>
<p>就我看來，台灣學生仍然過於理想，卻安於現狀。與此同時，對待同輩或小一輩人物，不僅不尊重對方人格，且霸陵現象非常嚴重，而他們自己又並未意識到這些問題，依舊嬉笑怒駡，語言粗俗低下。</p>
<p>或許是我自身不善於和人交流，或過於冷漠，專注于自身，而不願加入或制止他們，也和我自身能力的不足有很大的關係。我在兵役期間，也多少遇到了被冷漠或無意識排擠，我也并不想要對目前公所所存在替代役，尋求幫助。而我也依舊保持著該需要我協助就站出來幫忙，該冷眼旁觀而專注于自身發展，便無視外界一切人。</p>
<p>因而2015年我對台灣的學生的大致印象，并不太好。或許是小島國思想封閉以及台灣這十幾年經濟的落寞，台灣學生的思維格局并沒有走出台灣，主要還是以“小確幸”為人生第一要緊事。台灣同樣也是，政治混亂，新聞媒體肆虐，狂舞台灣。無論是食安、黨派、房價、薪資、兩岸等問題，都是台灣人目前還沒辦法解決的各個病痛。台灣雖然醫學世界有名，卻沒辦法合理手術自己身上那顆巨大的腫瘤。</p>
<h2 id="3-_u5927_u81F4_u90FD_u770B_u4E86_u54EA_u4E9B_u66F8"><a href="#3-_u5927_u81F4_u90FD_u770B_u4E86_u54EA_u4E9B_u66F8" class="headerlink" title="3.大致都看了哪些書"></a>3.大致都看了哪些書</h2><p>今年閱讀量大約在25﹣30本書左右，同時閱讀了大量Blog，網站文章，微信公眾號，簡書、知乎、微博、Twitter資源等等。另外還看了很多電影，但是我只看不喜歡寫影評，因而就沒有進行統計。</p>
<p>有的書看了不止一次，像《把時間當做朋友》就至少看了三次，仍然覺得還有很多地方可以學習。</p>
<a id="more"></a>
<p>以下書籍不分閱讀順序，10名以後無好壞排序，10名以內的書都值得看3遍以上。</p>
<p>1.《賈伯斯傳》</p>
<p>2.《把時間當做朋友》</p>
<p>3.《iOS_Apprentice》系列，共四本，By Ray WenderLich家</p>
<p>4.《三體》</p>
<p>5.《成為賈伯斯──天才巨星的挫敗與孕成》</p>
<p>6.《演算法統治世界》</p>
<p>7.《養成iOS8APP──程式設計實力的25堂課》</p>
<p>8.《2014﹣2019經濟大懸崖》</p>
<p>9.《微反應》</p>
<p>10.《內向者的優勢》</p>
<p>11.《這個設計好在哪？》</p>
<p>12.《大和魂》</p>
<p>13.《走向世界！哈佛、牛津教你如何鍛鍊思考力》</p>
<p>14.《奇特的一生》</p>
<p>15.《黑客與畫家》</p>
<p>16.《我是一個算命先生2》</p>
<p>17.《深度學習的藝術》</p>
<p>18.《過把癮就死》</p>
<p>19.《拆掉思維里的墻》</p>
<p>20.《高效人士的7種習慣》</p>
<p>21.《IT人的MacTalk》</p>
<p>22.《不看盤投資術》</p>
<p>23.《20幾歲就定位》</p>
<p>24.《學習之道》</p>
<p>25.《我也曾經上班一個禮拜就辭職》</p>
<p>26.《創業時，我們在知乎聊什麼？》</p>
<p>27.《北洋裂變：軍閥與五四》</p>
<h2 id="2016_u5E74_u4E4B_u9032_u4E00_u6B65_u7684_u6253_u7B97"><a href="#2016_u5E74_u4E4B_u9032_u4E00_u6B65_u7684_u6253_u7B97" class="headerlink" title="2016年之進一步的打算"></a>2016年之進一步的打算</h2><p>1.進一步增加每天的Coding時間，同時閱讀GitHub上的源碼。</p>
<p>2.做出2件以上的App。</p>
<p>3.盡力熟練Objective-C。</p>
<p>4.欣賞更多設計作品。</p>
<p>5.爭取閱讀30﹣40本書。</p>
<p>6.每週鍛鍊1﹣2小時，養好身體。</p>
<p>7.提高每天背單詞的數量，提高英語能力。</p>
<p>8.定期寫博客對知識進行總結與分享。</p>
<h2 id="4-_u8CFC_u8CB7_u7684_u90A3_u4E9B_u6771_u897F"><a href="#4-_u8CFC_u8CB7_u7684_u90A3_u4E9B_u6771_u897F" class="headerlink" title="4.購買的那些東西"></a>4.購買的那些東西</h2><p>1.Macbook Pro, 2015年2月13日購買。</p>
<p>2.iPad Air 2, 2015年7月11日購買。</p>
<p>3.克補＋鋅，補充維他命B群等元素。</p>
<p>4.大量的書。</p>
<p>5.GU上的一件黑色大衣，新揹包。</p>
<p>6.巨匠補習班上的技能學習。</p>
<h2 id="5-Mac_u4E0A_u4F7F_u7528_u7684_u8EDF_u4EF6"><a href="#5-Mac_u4E0A_u4F7F_u7528_u7684_u8EDF_u4EF6" class="headerlink" title="5.Mac上使用的軟件"></a>5.Mac上使用的軟件</h2><p>1.Xcode.</p>
<p>2.Photoshop CC 2015</p>
<p>3.Reeder</p>
<p>4.Pomodoro One</p>
<p>5.GitHub Desktop</p>
<p>6.MacDown</p>
<p>7.Twitter</p>
<p>8.AppCleaner</p>
<p>9.Battery Health</p>
<p>10.CleanMyMac 3</p>
<p>11.BetterZip 3.0</p>
<p>12.Hear</p>
<p>13.Infinit</p>
<p>14.Hearthstone</p>
<p>15.Manico</p>
<p>16.RescueTime</p>
<p>17.This War of Mine</p>
<h2 id="6-iPad_u4E0A_u4F7F_u7528_u7684_u8EDF_u4EF6"><a href="#6-iPad_u4E0A_u4F7F_u7528_u7684_u8EDF_u4EF6" class="headerlink" title="6.iPad上使用的軟件"></a>6.iPad上使用的軟件</h2><p>1.即時天氣</p>
<p>2.Gmail</p>
<p>3.WeChat</p>
<p>4.知乎日報、知乎、開發者頭條</p>
<p>5.Sleep Better</p>
<p>6.半糖</p>
<p>7.AppSo</p>
<p>8.Infinit</p>
<p>9.扇貝單詞</p>
<p>10.CodeHub</p>
<p>11.iBooks</p>
<p>12.Monument、Cytus、Implosion</p>
<p>13.Pinterest</p>
<p>14.爐石戰記</p>
<p>15.微博</p>
<p>16.Twitter</p>
<p>17.Kindle</p>
<p>18.網易公開課</p>
]]></content:encoded>
      <comments>http://yoursite.com/2016/01/01/2015%E5%B9%B4%E5%9B%9E%E9%A1%A7%E8%88%87%E7%B8%BD%E7%B5%90/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
